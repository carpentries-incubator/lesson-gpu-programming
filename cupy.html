<!DOCTYPE html>
<!-- START: inst/pkgdown/templates/layout.html --><!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><title>GPU Programming: Using your GPU with CuPy</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" type="text/css" href="assets/styles.css"><script src="assets/scripts.js" type="text/javascript"></script><!-- mathjax --><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      config: ["MMLorHTML.js"],
      jax: ["input/TeX","input/MathML","output/HTML-CSS","output/NativeMML", "output/PreviewHTML"],
      extensions: ["tex2jax.js","mml2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
      TeX: {
        extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
      },
      tex2jax: {
        inlineMath: [ ['$','$'], ['\\(', '\\)']],
        displayMath: [ ['$$','$$'], ['\\[', '\\]'] ],
        processEscapes: true
      }
    });
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><!-- Responsive Favicon for The Carpentries --><link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png"><link rel="manifest" href="site.webmanifest"><link rel="mask-icon" href="safari-pinned-tab.svg" color="#5bbad5"><meta name="msapplication-TileColor" content="#da532c"><meta name="theme-color" content="#ffffff"></head><body>
    <header id="top" class="navbar navbar-expand-md navbar-light bg-white top-nav incubator"><a class="visually-hidden-focusable skip-link" href="#main-content">Skip to main content</a>
  <div class="container-fluid top-nav-container">
    <div class="col-md-6">
      <div class="large-logo">
        <img alt="Carpentries Incubator" src="assets/images/incubator-logo.svg"><abbr class="icon" title="This lesson is in the beta phase, which means that it is ready for teaching by instructors outside of the original author team." style="text-decoration: unset">
           
          <a href="https://cdh.carpentries.org/the-lesson-life-cycle.html#polishing-beta-stage" class="external-link alert-link" style="color: #383838">Beta
            <i aria-hidden="true" class="icon" data-feather="alert-circle" style="color: #001483; border-radius: 5px"></i>
          </a>
          <span class="visually-hidden">This lesson is in the beta phase, which means that it is ready for teaching by instructors outside of the original author team.</span>
        </abbr>
        
      </div>
    </div>
    <div class="selector-container ">
      
      
      <div class="dropdown">
        <button class="btn btn-secondary dropdown-toggle bordered-button" type="button" id="dropdownMenu1" data-bs-toggle="dropdown" aria-expanded="false">
          <i aria-hidden="true" class="icon" data-feather="eye"></i> Learner View <i data-feather="chevron-down"></i>
        </button>
        <ul class="dropdown-menu" aria-labelledby="dropdownMenu1"><li><button class="dropdown-item" type="button" onclick="window.location.href='instructor/cupy.html';">Instructor View</button></li>
        </ul></div>
    </div>
  </div>
  <hr></header><nav class="navbar navbar-expand-xl navbar-light bg-white bottom-nav incubator" aria-label="Main Navigation"><div class="container-fluid nav-container">
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
      <span class="menu-title">Menu</span>
    </button>
    <div class="nav-logo">
      <img class="small-logo" alt="Carpentries Incubator" src="assets/images/incubator-logo-sm.svg"></div>
    <div class="lesson-title-md">
      GPU Programming
    </div>
    <div class="search-icon-sm">
      <!-- TODO: do not show until we have search
      <i role="img" aria-label="search button" data-feather="search"></i>
      -->
    </div>
    <div class="desktop-nav">
      <ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item">
          <span class="lesson-title">
            GPU Programming
          </span>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="key-points.html">Key Points</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="reference.html#glossary">Glossary</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="profiles.html">Learner Profiles</a>
        </li>
        <li class="nav-item dropdown">
          <button class="nav-link dropdown-toggle" id="navbarDropdown" data-bs-toggle="dropdown" aria-expanded="false">
            More <i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu" aria-labelledby="navbarDropdown"><li><a class="dropdown-item" href="reference.html">Reference</a></li>
          </ul></li>
      </ul></div>
    <form class="d-flex col-md-2 search-form">
      <fieldset disabled><input class="form-control me-2 searchbox" type="search" placeholder="Search" aria-label="Search"><button class="btn btn-outline-success tablet-search-button" type="submit">
          <i class="search-icon" data-feather="search" role="img" aria-label="search button"></i>
        </button>
      </fieldset></form>
  </div><!--/div.container-fluid -->
</nav><div class="col-md-12 mobile-title">
  GPU Programming
</div>

<aside class="col-md-12 lesson-progress"><div style="width: 2%" class="percentage">
    2%
  </div>
  <div class="progress incubator">
    <div class="progress-bar incubator" role="progressbar" style="width: 2%" aria-valuenow="2" aria-label="Lesson Progress" aria-valuemin="0" aria-valuemax="100">
    </div>
  </div>
</aside><div class="container">
      <div class="row">
        <!-- START: inst/pkgdown/templates/navbar.html -->
  <div id="sidebar-col" class="col-lg-4">
    <div id="sidebar" class="sidebar">
      <nav aria-labelledby="flush-headingEleven"><button role="button" aria-label="close menu" alt="close menu" aria-expanded="true" aria-controls="sidebar" class="collapse-toggle"><i class="search-icon" data-feather="x" role="img"></i></button>
        <div class="sidebar-inner">
          <div class="row mobile-row">
            <div class="col">
              <div class="sidenav-view-selector">
                <div class="accordion accordion-flush" id="accordionFlush9">
                  <div class="accordion-item">
                    <h2 class="accordion-header" id="flush-headingNine">
                      <button class="accordion-button collapsed" id="instructor" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseNine" aria-expanded="false" aria-controls="flush-collapseNine">
                        <i id="eye" aria-hidden="true" class="icon" data-feather="eye"></i> Learner View
                      </button>
                    </h2>
                    <div id="flush-collapseNine" class="accordion-collapse collapse" aria-labelledby="flush-headingNine" data-bs-parent="#accordionFlush2">
                      <div class="accordion-body">
                        <a href="instructor/cupy.html">Instructor View</a>
                      </div>
                    </div>
                  </div><!--/div.accordion-item-->
                </div><!--/div.accordion-flush-->
              </div><!--div.sidenav-view-selector -->
            </div><!--/div.col -->
      
            <hr></div><!--/div.mobile-row -->

          <div class="accordion accordion-flush" id="accordionFlush11">
            <div class="accordion-item">

              <button id="chapters" class="accordion-button show" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseEleven" aria-expanded="false" aria-controls="flush-collapseEleven">
                <h2 class="accordion-header chapters" id="flush-headingEleven">
                  EPISODES
                </h2>
              </button>
              <div id="flush-collapseEleven" class="accordion-collapse show collapse" aria-labelledby="flush-headingEleven" data-bs-parent="#accordionFlush11">

                <div class="accordion-body">
                  <div class="accordion accordion-flush" id="accordionFlush1">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading1">
        <a href="index.html">Summary and Setup</a>
    </div><!--/div.accordion-header-->
        
  </div><!--/div.accordion-item-->
</div><!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush2">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading2">
        <a href="introduction.html">1. Introduction</a>
    </div><!--/div.accordion-header-->
        
  </div><!--/div.accordion-item-->
</div><!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlushcurrent">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-headingcurrent">
        <span class="visually-hidden">Current Chapter</span>
        <span class="current-chapter">
        2. Using your GPU with CuPy
        </span>
      
    </div><!--/div.accordion-header-->
        
  </div><!--/div.accordion-item-->
</div><!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush4">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading4">
        <a href="numba.html">3. Accelerate your Python code with Numba</a>
    </div><!--/div.accordion-header-->
        
  </div><!--/div.accordion-item-->
</div><!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush5">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading5">
        <a href="gpu_introduction.html">4. A Better Look at the GPU</a>
    </div><!--/div.accordion-header-->
        
  </div><!--/div.accordion-item-->
</div><!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush6">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading6">
        <a href="first_program.html">5. Your First GPU Kernel</a>
    </div><!--/div.accordion-header-->
        
  </div><!--/div.accordion-item-->
</div><!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush7">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading7">
        <a href="global_local_memory.html">6. Registers, Global, and Local Memory</a>
    </div><!--/div.accordion-header-->
        
  </div><!--/div.accordion-item-->
</div><!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush8">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading8">
        <a href="shared_memory_and_synchronization.html">7. Shared Memory and Synchronization</a>
    </div><!--/div.accordion-header-->
        
  </div><!--/div.accordion-item-->
</div><!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush9">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading9">
        <a href="constant_memory.html">8. Constant Memory</a>
    </div><!--/div.accordion-header-->
        
  </div><!--/div.accordion-item-->
</div><!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush10">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading10">
        <a href="streams.html">9. Concurrent access to the GPU</a>
    </div><!--/div.accordion-header-->
        
  </div><!--/div.accordion-item-->
</div><!--/div.accordion-flush-->

                </div>
              </div>
            </div>

            <hr class="half-width"><div class="accordion accordion-flush resources" id="accordionFlush12">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-headingTwelve">
                  <button class="accordion-button collapsed" id="resources" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseTwelve" aria-expanded="false" aria-controls="flush-collapseTwelve">
                    RESOURCES
                  </button>
                </h2>
                <div id="flush-collapseTwelve" class="accordion-collapse collapse" aria-labelledby="flush-headingTwelve" data-bs-parent="#accordionFlush12">
                  <div class="accordion-body">
                    <ul><li>
                        <a href="key-points.html">Key Points</a>
                      </li>
                      <li>
                        <a href="reference.html#glossary">Glossary</a>
                      </li>
                      <li>
                        <a href="profiles.html">Learner Profiles</a>
                      </li>
                      <li><a href="reference.html">Reference</a></li>
                    </ul></div>
                </div>
              </div>
            </div>
            <hr class="half-width resources"><a href="aio.html">See all in one page</a>

            <hr class="d-none d-sm-block d-md-none"><div class="d-grid gap-1">
            
            </div>
          </div><!-- /div.accordion -->
        </div><!-- /div.sidebar-inner -->
      </nav></div><!-- /div.sidebar -->
  </div><!-- /div.sidebar-col -->
<!-- END:   inst/pkgdown/templates/navbar.html-->

        <!-- START: inst/pkgdown/templates/content-instructor.html -->
  <div class="col-xl-8 col-lg-12 primary-content">
    <nav class="lesson-content mx-md-4" aria-label="Previous and Next Chapter"><!-- content for small screens --><div class="d-block d-sm-block d-md-none">
        <a class="chapter-link" href="introduction.html"><i aria-hidden="true" class="small-arrow" data-feather="arrow-left"></i>Previous</a>
        <a class="chapter-link float-end" href="numba.html">Next<i aria-hidden="true" class="small-arrow" data-feather="arrow-right"></i></a>
      </div>
      <!-- content for large screens -->
      <div class="d-none d-sm-none d-md-block">
        <a class="chapter-link" href="introduction.html" rel="prev"><i aria-hidden="true" class="small-arrow" data-feather="arrow-left"></i>Previous: Introduction</a>
        <a class="chapter-link float-end" href="numba.html" rel="next">Next: Accelerate your... <i aria-hidden="true" class="small-arrow" data-feather="arrow-right"></i></a>
      </div>
      <hr></nav><main id="main-content" class="main-content"><div class="container lesson-content">
        <h1>Using your GPU with CuPy</h1>
        <p> Last updated on 2023-07-11 | 
        
        <a href="https://github.com/carpentries-incubator/lesson-gpu-programming/edit/main/episodes/cupy.Rmd" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
        
        
        
        <div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right"> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>

        

<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul><li>“How can I increase the performance of code that uses NumPy?”</li>
<li>“How can I copy NumPy arrays to the GPU?”</li>
</ul></div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul><li>“Be able to indicate if an array, represented by a variable in an
iPython shell, is stored in host or device memory.”</li>
<li>“Be able to copy the contents of this array from host to device
memory and vice versa.”</li>
<li>“Be able to select the appropriate function to either convolve an
image using either CPU or GPU compute power.”</li>
<li>“Be able to quickly estimate the speed benefits for a simple
calculation by moving it from the CPU to the GPU.”</li>
</ul></div>
</div>
</div>
</div>
</div>
<div class="section level1">
<h1 id="introduction-to-cupy">Introduction to CuPy<a class="anchor" aria-label="anchor" href="#introduction-to-cupy"></a></h1>
<p><a href="https://cupy.dev" class="external-link">CuPy</a> is a GPU array library that
implements a subset of the NumPy and SciPy interfaces. This makes it a
very convenient tool to use the compute power of GPUs for people that
have some experience with NumPy, without the need to write code in a GPU
programming language such as CUDA, OpenCL, or HIP.</p>
</div>
<div class="section level1">
<h1 id="convolution-in-python">Convolution in Python<a class="anchor" aria-label="anchor" href="#convolution-in-python"></a></h1>
<p>We start by generating an artificial “image” on the host using Python
and NumPy; the host is the CPU on the laptop, desktop, or cluster node
you are using right now, and from now on we may use <em>host</em> to
refer to the CPU and <em>device</em> to refer to the GPU. The image will
be all zeros, except for isolated pixels with value one, on a regular
grid. The plan is to convolve it with a Gaussian and inspect the result.
We will also record the time it takes to execute this convolution on the
host.</p>
<p>We can interactively write and executed the code in an iPython shell
or a Jupyter notebook.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Construct an image with repeated delta functions</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>deltas <span class="op">=</span> np.zeros((<span class="dv">2048</span>, <span class="dv">2048</span>))</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>deltas[<span class="dv">8</span>::<span class="dv">16</span>,<span class="dv">8</span>::<span class="dv">16</span>] <span class="op">=</span> <span class="dv">1</span></span></code></pre>
</div>
<p>To get a feeling of how the whole image looks like, we can display
the top-left corner of it.</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pylab <span class="im">as</span> pyl</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Necessary command to render a matplotlib image in a Jupyter notebook.</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Display the image</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co"># You can zoom in using the menu in the window that will appear</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>pyl.imshow(deltas[<span class="dv">0</span>:<span class="dv">32</span>, <span class="dv">0</span>:<span class="dv">32</span>])</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>pyl.show()</span></code></pre>
</div>
<p>After executing the code, you should see the following image.</p>
<figure><img src="./fig/deltas.png" alt="Deltas array" class="figure mx-auto d-block"><figcaption>Deltas array</figcaption></figure><div class="section level3">
<h3 id="background">Background<a class="anchor" aria-label="anchor" href="#background"></a></h3>
<p>The computation we want to perform on this image is a convolution,
once on the host and once on the device so we can compare the results
and execution times. In computer vision applications, convolutions are
often used to filter images and if you want to know more about them, we
encourage you to check out <a href="https://github.com/vdumoulin/conv_arithmetic" class="external-link">this github
repository</a> by Vincent Dumoulin and Francesco Visin with some great
animations. We have already seen that we can think of an image as a
matrix of color values, when we convolve that image with a particular
filter, we generate a new matrix with different color values. An example
of convolution can be seen in the figure below (illustration by Michael
Plotke, CC BY-SA 3.0, via Wikimedia Commons).</p>
<figure><img src="./fig/2D_Convolution_Animation.gif" alt="Example of animated convolution" class="figure mx-auto d-block"><figcaption>Example of animated convolution</figcaption></figure><p>In our example, we will convolve our image with a 2D Gaussian
function shown below:</p>
<p><span class="math display">\[G(x,y) = \frac{1}{2\pi \sigma^2}
\exp\left(-\frac{x^2 + y^2}{2 \sigma^2}\right),\]</span></p>
<p>where <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> are the “coordinates in our matrix,
i.e. our row and columns, and <span class="math display">\[\sigma\]</span> controls the width of the
Gaussian distribution. Convolving images with 2D Gaussian functions will
change the value of each pixel to be a weighted average of the pixels
around it, thereby”smoothing” the image. Convolving images with a
Gaussian function reduces the noise in the image, which is often
required in <a href="https://en.wikipedia.org/wiki/Gaussian_blur#Edge_detection" class="external-link">edge-detection</a>
since most algorithms to do this are sensitive to noise.</p>
<div id="callout1" class="callout callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout<a class="anchor" aria-label="anchor" href="#callout1"></a>
</h3>
<div class="callout-content">
<p>It is often useful to identify the dataflow inherent in a problem.
Say, if we want to square a list of numbers, all the operations are
independent. The dataflow of a one-to-one operation is called a
<em>map</em>.</p>
<figure><img src="./fig/mapping.svg" alt="Data flow of a map operation" class="figure mx-auto d-block"><figcaption>Data flow of a map operation</figcaption></figure><p>A convolution is slightly more complicated. Here we have a
many-to-one data flow, which is also known as a stencil.</p>
<figure><img src="./fig/stencil.svg" alt="Data flow of a stencil operation" class="figure mx-auto d-block"><figcaption>Data flow of a stencil operation</figcaption></figure><p>GPU’s are exceptionally well suited to compute algorithms that follow
one of these patterns.</p>
</div>
</div>
</div>
</div>
</div>
<div class="section level1">
<h1 id="convolution-on-the-cpu-using-scipy">Convolution on the CPU Using SciPy<a class="anchor" aria-label="anchor" href="#convolution-on-the-cpu-using-scipy"></a></h1>
<p>Let us first construct the Gaussian, and then display it. Remember
that at this point we are still doing everything with standard Python,
and not using the GPU yet.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>x, y <span class="op">=</span> np.meshgrid(np.linspace(<span class="op">-</span><span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">15</span>), np.linspace(<span class="op">-</span><span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">15</span>))</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>dst <span class="op">=</span> np.sqrt(x<span class="op">*</span>x <span class="op">+</span> y<span class="op">*</span>y)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>muu <span class="op">=</span> <span class="fl">0.000</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>gauss <span class="op">=</span> np.exp(<span class="op">-</span>((dst<span class="op">-</span>muu)<span class="op">**</span><span class="dv">2</span><span class="op">/</span>(<span class="fl">2.0</span> <span class="op">*</span> sigma<span class="op">**</span><span class="dv">2</span>)))</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>pyl.imshow(gauss)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>pyl.show()</span></code></pre>
</div>
<p>This should show you a symmetrical two-dimensional Gaussian.</p>
<figure><img src="./fig/gauss.png" alt="Two-dimensional Gaussian" class="figure mx-auto d-block"><figcaption>Two-dimensional Gaussian</figcaption></figure><p>Now we are ready to do the convolution on the host. We do not have to
write this convolution function ourselves, as it is very conveniently
provided by SciPy. Let us also record the time it takes to perform this
convolution and inspect the top left corner of the convolved image.</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.signal <span class="im">import</span> convolve2d <span class="im">as</span> convolve2d_cpu</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>convolved_image_using_CPU <span class="op">=</span> convolve2d_cpu(deltas, gauss)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>pyl.imshow(convolved_image_using_CPU[<span class="dv">0</span>:<span class="dv">32</span>, <span class="dv">0</span>:<span class="dv">32</span>])</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>pyl.show()</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit <span class="op">-</span>n <span class="dv">1</span> <span class="op">-</span>r <span class="dv">1</span> convolve2d_cpu(deltas, gauss)</span></code></pre>
</div>
<p>Obviously, the time to perform this convolution will depend very much
on the power of your CPU, but I expect you to find that it takes a
couple of seconds.</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>2.4 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)</code></pre>
</div>
<p>When you display the corner of the image, you can see that the “ones”
surrounded by zeros have actually been blurred by a Gaussian, so we end
up with a regular grid of Gaussians.</p>
<figure><img src="./fig/convolved_image.png" alt="Regular grid of Gaussians" class="figure mx-auto d-block"><figcaption>Regular grid of Gaussians</figcaption></figure></div>
<div class="section level1">
<h1 id="convolution-on-the-gpu-using-cupy">Convolution on the GPU Using CuPy<a class="anchor" aria-label="anchor" href="#convolution-on-the-gpu-using-cupy"></a></h1>
<p>This is part of a lesson on GPU programming, so let us use the GPU.
Although there is a physical connection - i.e. a cable - between the CPU
and the GPU, they do not share the same memory space. This image depicts
the different components of CPU and GPU and how they are connected:</p>
<figure><img src="./fig/CPU_and_GPU_separated.png" alt="CPU and GPU are two separate entities, each with its own memory" class="figure mx-auto d-block"><figcaption>CPU and GPU are two separate entities, each with its
own memory</figcaption></figure><p>This means that an array created from e.g. an iPython shell using
NumPy is physically located into the main memory of the host, and
therefore available for the CPU but not the GPU. It is not yet present
in GPU memory, which means that we need to copy our data, the input
image and the convolving function to the GPU, before we can execute any
code on it. In practice, we have the arrays <code>deltas</code> and
<code>gauss</code> in the host’s RAM, and we need to copy them to GPU
memory using CuPy.</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cupy <span class="im">as</span> cp</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>deltas_gpu <span class="op">=</span> cp.asarray(deltas)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>gauss_gpu <span class="op">=</span> cp.asarray(gauss)</span></code></pre>
</div>
<p>Now it is time to do the convolution on the GPU. SciPy does not offer
functions that can use the GPU, so we need to import the convolution
function from another library, called <code>cupyx</code>;
<code>cupyx.scipy</code> contains a subset of all SciPy routines. You
will see that the GPU convolution function from the <code>cupyx</code>
library looks very much like the convolution function from SciPy we used
previously. In general, NumPy and CuPy look very similar, as well as the
SciPy and <code>cupyx</code> libraries, and this is on purpose to
facilitate the use of the GPU by programmers that are already familiar
with NumPy and SciPy. Let us again record the time to execute the
convolution, so that we can compare it with the time it took on the
host.</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> cupyx.scipy.signal <span class="im">import</span> convolve2d <span class="im">as</span> convolve2d_gpu</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>convolved_image_using_GPU <span class="op">=</span> convolve2d_gpu(deltas_gpu, gauss_gpu)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit <span class="op">-</span>n <span class="dv">7</span> <span class="op">-</span>r <span class="dv">1</span> convolved_image_using_GPU <span class="op">=</span> convolve2d_gpu(deltas_gpu, gauss_gpu)</span></code></pre>
</div>
<p>Similar to what we had previously on the host, the execution time of
the GPU convolution will depend very much on the GPU used. These are the
results using a NVIDIA Tesla T4 on Google Colab.</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>98.2 µs ± 0 ns per loop (mean ± std. dev. of 1 run, 7 loops each)</code></pre>
</div>
<p>This is a lot faster than on the host, a performance improvement, or
speedup, of 24439 times. Impressive, but is it true?</p>
</div>
<div class="section level1">
<h1 id="measuring-performance">Measuring performance<a class="anchor" aria-label="anchor" href="#measuring-performance"></a></h1>
<p>So far we used <code>timeit</code> to measure the performance of our
Python code, no matter if it was running on the CPU or was GPU
accelerated. However, execution on the GPU is asynchronous: the control
is given back to the Python interpreter immediately, while the GPU is
still executing the task. Because of this, we cannot use
<code>timeit</code> anymore: the timing would not be correct.</p>
<p>CuPy provides a function, <code>benchmark</code> that we can use to
measure the time it takes the GPU to execute our kernels.</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> cupyx.profiler <span class="im">import</span> benchmark</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>execution_gpu <span class="op">=</span> benchmark(convolve2d_gpu, (deltas_gpu, gauss_gpu), n_repeat<span class="op">=</span><span class="dv">10</span>)</span></code></pre>
</div>
<p>The previous code executes <code>convolve2d_gpu</code> ten times, and
stores the execution time of each run, in seconds, inside the
<code>gpu_times</code> attribute of the variable
<code>execution_gpu</code>. We can then compute the average execution
time and print it, as shown.</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>gpu_avg_time <span class="op">=</span> np.average(execution_gpu.gpu_times)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>gpu_avg_time<span class="sc">:.6f}</span><span class="ss"> s"</span>)</span></code></pre>
</div>
<p>Another advantage of the <code>benchmark</code> method is that it
excludes the compile time, and warms up the GPU, so that measurements
are more stable and representative.</p>
<p>With the new measuring code in place, we can measure performance
again.</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>0.020642 s</code></pre>
</div>
<p>We now have a more reasonable, but still impressive, speedup of 116
times over the host code.</p>
<div id="challenge-convolution-on-the-gpu-without-cupy" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-convolution-on-the-gpu-without-cupy" class="callout-inner">
<h3 class="callout-title">Challenge: convolution on the GPU without
CuPy<a class="anchor" aria-label="anchor" href="#challenge-convolution-on-the-gpu-without-cupy"></a>
</h3>
<div class="callout-content">
<p>Try to convolve the NumPy array <code>deltas</code> with the NumPy
array <code>gauss</code> directly on the GPU, without using CuPy arrays.
If this works, it should save us the time and effort of transferring
<code>deltas</code> and <code>gauss</code> to the GPU.</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1">
  Show me the solution
  </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<p>We can directly try to use the GPU convolution function
<code>convolve2d_gpu</code> with <code>deltas</code> and
<code>gauss</code> as inputs.</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>convolve2d_gpu(deltas, gauss)</span></code></pre>
</div>
<p>However, this gives a long error message ending with:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>TypeError: Unsupported type &lt;class 'numpy.ndarray'&gt;</code></pre>
</div>
<p>It is unfortunately not possible to access NumPy arrays directly from
the GPU because they exist in the Random Access Memory (RAM) of the host
and not in GPU memory.</p>
</div>
</div>
</div>
</div>
</div>
<div class="section level1">
<h1 id="validation">Validation<a class="anchor" aria-label="anchor" href="#validation"></a></h1>
<p>To check that we actually computed the same output on the host and
the device we can compare the two output arrays
<code>convolved_image_using_GPU</code> and
<code>convolved_image_using_CPU</code>.</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>np.allclose(convolved_image_using_GPU, convolved_image_using_CPU)</span></code></pre>
</div>
<p>As you may expect, the result of the comparison is positive, and in
fact we computed the same results on the host and the device.</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="fu">array</span><span class="op">(</span><span class="va">True</span><span class="op">)</span></span></code></pre>
</div>
<div id="challenge-fairer-comparison-of-cpu-vs.-gpu" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-fairer-comparison-of-cpu-vs.-gpu" class="callout-inner">
<h3 class="callout-title">Challenge: fairer comparison of CPU
vs. GPU<a class="anchor" aria-label="anchor" href="#challenge-fairer-comparison-of-cpu-vs.-gpu"></a>
</h3>
<div class="callout-content">
<p>Compute again the speedup achieved using the GPU, but try to take
also into account the time spent transferring the data to the GPU and
back.</p>
<p>Hint: to copy a CuPy array back to the host (CPU), use the
<code>cp.asnumpy()</code> function.</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2">
  Show me the solution
  </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" data-bs-parent="#accordionSolution2" aria-labelledby="headingSolution2">
<div class="accordion-body">
<p>A convenient solution is to group both the transfers, to and from the
GPU, and the convolution into a single Python function, and then time
its execution, like in the following example.</p>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> transfer_compute_transferback():</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    deltas_gpu <span class="op">=</span> cp.asarray(deltas)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    gauss_gpu <span class="op">=</span> cp.asarray(gauss)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    convolved_image_using_GPU <span class="op">=</span> convolve2d_gpu(deltas_gpu, gauss_gpu)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    convolved_image_using_GPU_copied_to_host <span class="op">=</span> cp.asnumpy(convolved_image_using_GPU)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>execution_gpu <span class="op">=</span> benchmark(transfer_compute_transferback, (), n_repeat<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>gpu_avg_time <span class="op">=</span> np.average(execution_gpu.gpu_times)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>gpu_avg_time<span class="sc">:.6f}</span><span class="ss"> s"</span>)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>0.035400 s</code></pre>
</div>
<p>The speedup taking into account the data transfers decreased from 116
to 67. Taking into account the necessary data transfers when computing
the speedup is a better, and more fair, way to compare performance. As a
note, because data transfers force the GPU to sync with the host, this
could also be measured with <code>timeit</code> and still provide
correct measurements.</p>
</div>
</div>
</div>
</div>
</div>
<div class="section level1">
<h1 id="a-shortcut-performing-numpy-routines-on-the-gpu">A shortcut: performing NumPy routines on the GPU<a class="anchor" aria-label="anchor" href="#a-shortcut-performing-numpy-routines-on-the-gpu"></a></h1>
<p>We saw earlier that we cannot execute routines from the
<code>cupyx</code> library directly on NumPy arrays. In fact we need to
first transfer the data from host to device memory. Vice versa, if we
try to execute a regular SciPy routine (i.e. designed to run the CPU) on
a CuPy array, we will also encounter an error. Try the following:</p>
<div class="codewrapper sourceCode" id="cb18">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>convolve2d_cpu(deltas_gpu, gauss_gpu)</span></code></pre>
</div>
<p>This results in</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>......
......
......
TypeError: Implicit conversion to a NumPy array is not allowed. Please use `.get()` to construct a NumPy array explicitly.</code></pre>
</div>
<p>So SciPy routines cannot have CuPy arrays as input. We can, however,
execute a simpler command that does not require SciPy. Instead of 2D
convolution, we can do 1D convolution. For that we can use a NumPy
routine instead of a SciPy routine. The <code>convolve</code> routine
from NumPy performs linear (1D) convolution. To generate some input for
a linear convolution, we can flatten our image from 2D to 1D (using
<code>ravel()</code>), but we also need a 1D kernel. For the latter we
will take the diagonal elements of our 2D Gaussian kernel. Try the
following three instructions for linear convolution on the CPU:</p>
<div class="codewrapper sourceCode" id="cb20">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>deltas_1d <span class="op">=</span> deltas.ravel()</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>gauss_1d <span class="op">=</span> gauss.diagonal()</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit <span class="op">-</span>n <span class="dv">1</span> <span class="op">-</span>r <span class="dv">1</span> np.convolve(deltas_1d, gauss_1d)</span></code></pre>
</div>
<p>You could arrive at something similar to this timing result:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>270 ms ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)</code></pre>
</div>
<p>We have performed a regular linear convolution using our CPU. Now let
us try something bold. We will transfer the 1D arrays to the GPU and use
the NumPy routine to do the convolution.</p>
<div class="codewrapper sourceCode" id="cb22">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>deltas_1d_gpu <span class="op">=</span> cp.asarray(deltas_1d)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>gauss_1d_gpu <span class="op">=</span> cp.asarray(gauss_1d)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>execution_gpu <span class="op">=</span> benchmark(np.convolve, (deltas_1d_gpu, gauss_1d_gpu), n_repeat<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>gpu_avg_time <span class="op">=</span> np.average(execution_gpu.gpu_times)</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>gpu_avg_time<span class="sc">:.6f}</span><span class="ss"> s"</span>)</span></code></pre>
</div>
<p>You may be surprised that we can issue these commands without error.
Contrary to SciPy routines, NumPy accepts CuPy arrays, i.e. arrays that
exist in GPU memory, as input. <a href="https://docs.cupy.dev/en/stable/user_guide/interoperability.html#numpy" class="external-link">In
the CuPy documentation</a> you can find some background on why NumPy
routines can handle CuPy arrays.</p>
<p>Also, remember when we used <code>np.allclose</code> with a NumPy and
a CuPy array as input? That worked for the same reason.</p>
<p>The linear convolution is actually performed on the GPU, which also
results in a lower execution time.</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>0.014529 s</code></pre>
</div>
<p>Without much effort, we obtained a 18 times speedup.</p>
</div>
<div class="section level1">
<h1 id="a-real-world-example-image-processing-for-radio-astronomy">A real world example: image processing for radio astronomy<a class="anchor" aria-label="anchor" href="#a-real-world-example-image-processing-for-radio-astronomy"></a></h1>
<p>In this section, we will perform the four major steps in image
processing for radio astronomy: determination of background
characteristics, segmentation, connected component labelling and source
measurements.</p>
<div class="section level2">
<h2 id="import-the-fits-image">Import the FITS image<a class="anchor" aria-label="anchor" href="#import-the-fits-image"></a></h2>
<p>Start by importing a 2048² pixels image of the Galactic Center, an
image made from observations by the Indian Giant Metrewave Radio
Telescope (GMRT) at 150 MHz. The image is stored <a href="./data/GMRT_image_of_Galactic_Center.fits">in this repository</a>
as a <a href="https://en.wikipedia.org/wiki/FITS" class="external-link">FITS</a> file, and to
read it we need the <code>astropy</code> Python package.</p>
<div class="codewrapper sourceCode" id="cb24">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> astropy.io <span class="im">import</span> fits</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> fits.<span class="bu">open</span>(<span class="st">"GMRT_image_of_Galactic_Center.fits"</span>) <span class="im">as</span> hdul:</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> hdul[<span class="dv">0</span>].data.byteswap().newbyteorder()</span></code></pre>
</div>
<p>The latter two methods are needed to convert byte ordering from big
endian to little endian.</p>
</div>
<div class="section level2">
<h2 id="inspect-the-image">Inspect the image<a class="anchor" aria-label="anchor" href="#inspect-the-image"></a></h2>
<p>Let us have a look at part of this image.</p>
<div class="codewrapper sourceCode" id="cb25">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib.colors <span class="im">import</span> LogNorm</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>maxim <span class="op">=</span> data.<span class="bu">max</span>()</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> pyl.figure(figsize<span class="op">=</span>(<span class="dv">50</span>, <span class="fl">12.5</span>))</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>im_plot <span class="op">=</span> ax.imshow(np.fliplr(data), cmap<span class="op">=</span>pyl.cm.gray_r, norm<span class="op">=</span>LogNorm(vmin <span class="op">=</span> maxim<span class="op">/</span><span class="dv">10</span>, vmax<span class="op">=</span>maxim<span class="op">/</span><span class="dv">100</span>))</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>pyl.colorbar(im_plot, ax<span class="op">=</span>ax)</span></code></pre>
</div>
<figure><img src="./fig/improved_image_of_GC.png" alt="Image of the Galactic Center" class="figure mx-auto d-block"><figcaption>Image of the Galactic Center</figcaption></figure><p>The data has been switched left to right because Right Ascension
increases to the left, so now it adheres to this astronomical
convention. We can see a few dozen sources, especially in the lower left
and upper right, which both have relatively good image quality. The band
across the image from upper left to lower right has the worst image
quality because there are many extended sources - especially the
Galactic Center itself, in the middle - which are hard to deconvolve
with the limited spacings from this observation. You can, however, see a
couple of ring-like structures. These are actually supernova shells,
i.e. the remnants from massive stars that exploded at the end of their
lifes.</p>
</div>
<div class="section level2">
<h2 id="determine-the-background-characteristics-of-the-image">Determine the background characteristics of the image<a class="anchor" aria-label="anchor" href="#determine-the-background-characteristics-of-the-image"></a></h2>
<p>We want to identify all the sources - meaning e.g. stars, supernova
remnants and distant galaxies - in this image and measure their
positions and fluxes. How do we separate source pixels from background
pixels? When do we know if a pixel with a high value belongs to a source
or is simply a noise peak? We assume the background noise, which is a
reflection of the limited sensitivity of the radio telescope, has a
normal distribution. The chance of having a background pixel with a
value above 5 times the standard deviation is 2.9e-7. We have 2²² =
4.2e6 pixels in our image, so the chance of catching at least one random
noise peak by setting a threshold of 5 times the standard deviation is
less than 50%. We refer to the standard deviation as <span class="math inline">\(\sigma\)</span>.</p>
<p>How do we measure the standard deviation of the background pixels?
First we need to separate them from the source pixels, based on their
values, in the sense that high pixel values more likely come from
sources. The technique we use is called <span class="math inline">\(\kappa, \sigma\)</span> clipping. First we take
all pixels and compute the standard deviation (<span class="math inline">\(\sigma\)</span>). Then we compute the median and
clip all pixels larger than <span class="math inline">\(median + 3 *
\sigma\)</span> and smaller than <span class="math inline">\(median - 3
* \sigma\)</span>. From the clipped set, we compute the median and
standard deviation again and clip again. Continue until no more pixels
are clipped. The standard deviation from this final set of pixel values
is the basis for the next step.</p>
<p>Before clipping, let us investigate some properties of our unclipped
data.</p>
<div class="codewrapper sourceCode" id="cb26">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>mean_ <span class="op">=</span> data.mean()</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>median_ <span class="op">=</span> np.median(data)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>stddev_ <span class="op">=</span> np.std(data)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>max_ <span class="op">=</span> np.amax(data)</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"mean = </span><span class="sc">{</span>mean_<span class="sc">:.3e}</span><span class="ss">, median = </span><span class="sc">{</span>median_<span class="sc">:.3e}</span><span class="ss">, sttdev = </span><span class="sc">{</span>stddev_<span class="sc">:.3e}</span><span class="ss">, </span><span class="ch">\</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="ss">maximum = </span><span class="sc">{</span>max_<span class="sc">:.3e}</span><span class="ss">"</span>)</span></code></pre>
</div>
<p>The maximum flux density is 2506 mJy/beam, coming from the Galactic
Center itself, so from the center of the image, while the overall
standard deviation is 19.9 mJy/beam:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>mean = 3.898e-04, median = 1.571e-05, sttdev = 1.993e-02, maximum = 2.506e+00</code></pre>
</div>
<p>You might observe that <span class="math inline">\(\kappa,
\sigma\)</span> clipping is a compute intense task, that is why we want
to do it on a GPU. But let’s first issue the algorithm on a CPU.</p>
<p>This is the NumPy code to do this:</p>
<div class="codewrapper sourceCode" id="cb28">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Flattening our 2D data first makes subsequent steps easier.</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>data_flat <span class="op">=</span> data.ravel()</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Here is a kappa, sigma clipper for the CPU</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kappa_sigma_clipper(data_flat):</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>         med <span class="op">=</span> np.median(data_flat)</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>         std <span class="op">=</span> np.std(data_flat)</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>         clipped_lower <span class="op">=</span> data_flat.compress(data_flat <span class="op">&gt;</span> med <span class="op">-</span> <span class="dv">3</span> <span class="op">*</span> std)</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>         clipped_both <span class="op">=</span> clipped_lower.compress(clipped_lower <span class="op">&lt;</span> med <span class="op">+</span> <span class="dv">3</span> <span class="op">*</span> std)</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>         <span class="cf">if</span> <span class="bu">len</span>(clipped_both) <span class="op">==</span> <span class="bu">len</span>(data_flat):</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>             <span class="cf">break</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>         data_flat <span class="op">=</span> clipped_both  </span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> data_flat</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>data_clipped <span class="op">=</span> kappa_sigma_clipper(data_flat)</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>timing_ks_clipping_cpu <span class="op">=</span> <span class="op">%</span>timeit <span class="op">-</span>o kappa_sigma_clipper(data_flat)</span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>fastest_ks_clipping_cpu <span class="op">=</span> timing_ks_clipping_cpu.best</span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Fastest CPU ks clipping time = </span><span class="ch">\</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a><span class="ss">       </span><span class="sc">{</span><span class="dv">1000</span> <span class="op">*</span> fastest_ks_clipping_cpu<span class="sc">:.3e}</span><span class="ss"> ms."</span>)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>793 ms ± 17.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
Fastest CPU ks clipping time = 7.777e+02 ms.</code></pre>
</div>
<p>So that is close to 1 second to perform these computations.
Hopefully, we can speed this up using the GPU. How has <span class="math inline">\(\kappa, \sigma\)</span> clipping influenced our
statistics?</p>
<div class="codewrapper sourceCode" id="cb30">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>clipped_mean_ <span class="op">=</span> data_clipped.mean()</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>clipped_median_ <span class="op">=</span> np.median(data_clipped)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>clipped_stddev_ <span class="op">=</span> np.std(data_clipped)</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>clipped_max_ <span class="op">=</span> np.amax(data_clipped)</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"mean of clipped = </span><span class="sc">{</span>clipped_mean_<span class="sc">:.3e}</span><span class="ss">, median of clipped = </span><span class="ch">\</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="sc">{</span>clipped_median_<span class="sc">:.3e}</span><span class="ss"> </span><span class="ch">\n</span><span class="ss"> standard deviation of clipped = </span><span class="ch">\</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="sc">{</span>clipped_stddev_<span class="sc">:.3e}</span><span class="ss">, maximum of clipped = </span><span class="sc">{</span>clipped_max_<span class="sc">:.3e}</span><span class="ss">"</span>)</span></code></pre>
</div>
<p>All output statistics have become smaller which is reassuring; it
seems data_clipped contains mostly background pixels:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>mean of clipped = -1.945e-06, median of clipped = -9.796e-06 
 standard deviation of clipped = 1.334e-02, maximum of clipped = 4.000e-02</code></pre>
</div>
<div id="challenge-kappa-sigma-clipping-on-the-gpu" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-kappa-sigma-clipping-on-the-gpu" class="callout-inner">
<h3 class="callout-title">Challenge: <span class="math inline">\(\kappa,
\sigma\)</span> clipping on the GPU<a class="anchor" aria-label="anchor" href="#challenge-kappa-sigma-clipping-on-the-gpu"></a>
</h3>
<div class="callout-content">
<p>Now that you understand how the <span class="math inline">\(\kappa,
\sigma\)</span> clipping algorithm works, perform it on the GPU using
CuPy and compute the speedup. Include the data transfer to and from the
GPU in your calculation.</p>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3">
  Show me the solution
  </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" data-bs-parent="#accordionSolution3" aria-labelledby="headingSolution3">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb32">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ks_clipper_gpu(data_flat):</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    data_flat_gpu <span class="op">=</span> cp.asarray(data_flat)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    data_gpu_clipped <span class="op">=</span> kappa_sigma_clipper(data_flat_gpu)</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cp.asnumpy(data_gpu_clipped)</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>data_clipped_on_GPU <span class="op">=</span> ks_clipper_gpu(data_flat)</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>timing_ks_clipping_gpu <span class="op">=</span> benchmark(ks_clipper_gpu, <span class="op">\</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>                                   (data_flat, ), n_repeat<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>fastest_ks_clipping_gpu <span class="op">=</span> np.amin(timing_ks_clipping_gpu.gpu_times)</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span><span class="dv">1000</span> <span class="op">*</span> fastest_ks_clipping_gpu<span class="sc">:.3e}</span><span class="ss"> ms"</span>)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>6.329e+01 ms</code></pre>
</div>
<div class="codewrapper sourceCode" id="cb34">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>speedup_factor <span class="op">=</span> fastest_ks_clipping_cpu<span class="op">/</span>fastest_ks_clipping_gpu</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The speedup factor for ks clipping is: </span><span class="sc">{</span>speedup_factor<span class="sc">:.3e}</span><span class="ss">"</span>)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>The speedup factor for ks clipping is: 1.232e+01</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="section level2">
<h2 id="segment-the-image">Segment the image<a class="anchor" aria-label="anchor" href="#segment-the-image"></a></h2>
<p>We have seen that clipping at the <span class="math inline">\(5
\sigma\)</span> level of an image this size (2048² pixels) will yield a
chance of less than 50% that from all the sources we detect at least one
will be a noise peak. So let us set the threshold at <span class="math inline">\(5 \sigma\)</span> and segment it. First check that
we find the same standard deviation from our clipper on the GPU:</p>
<div class="codewrapper sourceCode" id="cb36">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>stddev_gpu_ <span class="op">=</span> np.std(data_clipped_on_GPU)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"standard deviation of background_noise = </span><span class="sc">{</span>stddev_gpu_<span class="sc">:.4f}</span><span class="ss"> Jy/beam"</span>)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>standard deviation of background_noise = 0.0133 Jy/beam</code></pre>
</div>
<p>With the standard deviation computed we apply the <span class="math inline">\(5 \sigma\)</span> threshold to the image.</p>
<div class="codewrapper sourceCode" id="cb38">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>threshold <span class="op">=</span> <span class="dv">5</span> <span class="op">*</span> stddev_gpu_</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>segmented_image <span class="op">=</span> np.where(data <span class="op">&gt;</span> threshold, <span class="dv">1</span>,  <span class="dv">0</span>)</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>timing_segmentation_CPU <span class="op">=</span> <span class="op">%</span>timeit <span class="op">-</span>o np.where(data <span class="op">&gt;</span> threshold, <span class="dv">1</span>,  <span class="dv">0</span>)</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>fastest_segmentation_CPU <span class="op">=</span> timing_segmentation_CPU.best </span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Fastest CPU segmentation time = </span><span class="sc">{</span><span class="dv">1000</span> <span class="op">*</span> fastest_segmentation_CPU<span class="sc">:.3e}</span><span class="ss"> </span><span class="ch">\</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="ss">ms."</span>)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>6.41 ms ± 55.3 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
Fastest CPU segmentation time = 6.294e+00 ms.</code></pre>
</div>
</div>
<div class="section level2">
<h2 id="labelling-of-the-segmented-data">Labelling of the segmented data<a class="anchor" aria-label="anchor" href="#labelling-of-the-segmented-data"></a></h2>
<p>This is called connected component labelling (CCL). It will replace
pixel values in the segmented image - just consisting of zeros and ones
- of the first connected group of pixels with the value 1 - so nothing
changed, but just for that first group - the pixel values in the second
group of connected pixels will all be 2, the third connected group of
pixels will all have the value 3 etc.</p>
<p>This is a CPU code for connected component labelling.</p>
<div class="codewrapper sourceCode" id="cb40">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.ndimage <span class="im">import</span> label <span class="im">as</span> label_cpu</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>labelled_image <span class="op">=</span> np.empty(data.shape)</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>number_of_sources_in_image <span class="op">=</span> label_cpu(segmented_image, output <span class="op">=</span> labelled_image)</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>sigma_unicode <span class="op">=</span> <span class="st">"</span><span class="ch">\u03C3</span><span class="st">"</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The number of sources in the image at the 5</span><span class="sc">{</span>sigma_unicode<span class="sc">}</span><span class="ss"> level is </span><span class="ch">\</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a><span class="sc">{</span>number_of_sources_in_image<span class="sc">}</span><span class="ss">."</span>)</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>timing_CCL_CPU <span class="op">=</span> <span class="op">%</span>timeit <span class="op">-</span>o label_cpu(segmented_image, output <span class="op">=</span> labelled_image)</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>fastest_CCL_CPU <span class="op">=</span> timing_CCL_CPU.best</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Fastest CPU CCL time = </span><span class="sc">{</span><span class="dv">1000</span> <span class="op">*</span> fastest_CCL_CPU<span class="sc">:.3e}</span><span class="ss"> ms."</span>)</span></code></pre>
</div>
<p>This gives, on my machine:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>The number of sources in the image at the 5σ level is 185.
26.3 ms ± 965 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
Fastest CPU CCL time = 2.546e+01 ms.</code></pre>
</div>
<p>Let us not just accept the answer, but also do a sanity check. What
are the values in the labelled image?</p>
<div class="codewrapper sourceCode" id="cb42">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"These are all the pixel values we can find in the labelled image: </span><span class="ch">\</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="sc">{</span>np<span class="sc">.</span>unique(labelled_image)<span class="sc">}</span><span class="ss">"</span>)</span></code></pre>
</div>
<p>This should show the following output:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>These are all the pixel values we can find in the labelled image: [  0.   1.   2.   3.   4.   5.   6.   7.   8.   9.  10.  11.  12.  13.
  14.  15.  16.  17.  18.  19.  20.  21.  22.  23.  24.  25.  26.  27.
  28.  29.  30.  31.  32.  33.  34.  35.  36.  37.  38.  39.  40.  41.
  42.  43.  44.  45.  46.  47.  48.  49.  50.  51.  52.  53.  54.  55.
  56.  57.  58.  59.  60.  61.  62.  63.  64.  65.  66.  67.  68.  69.
  70.  71.  72.  73.  74.  75.  76.  77.  78.  79.  80.  81.  82.  83.
  84.  85.  86.  87.  88.  89.  90.  91.  92.  93.  94.  95.  96.  97.
  98.  99. 100. 101. 102. 103. 104. 105. 106. 107. 108. 109. 110. 111.
 112. 113. 114. 115. 116. 117. 118. 119. 120. 121. 122. 123. 124. 125.
 126. 127. 128. 129. 130. 131. 132. 133. 134. 135. 136. 137. 138. 139.
 140. 141. 142. 143. 144. 145. 146. 147. 148. 149. 150. 151. 152. 153.
 154. 155. 156. 157. 158. 159. 160. 161. 162. 163. 164. 165. 166. 167.
 168. 169. 170. 171. 172. 173. 174. 175. 176. 177. 178. 179. 180. 181.
 182. 183. 184. 185.]</code></pre>
</div>
</div>
</div>
<div class="section level1">
<h1 id="source-measurements">Source measurements<a class="anchor" aria-label="anchor" href="#source-measurements"></a></h1>
<p>We are ready for the final step. We have been given observing time to
make this beautiful image of the Galactic Center, we have determined its
background statistics, we have separated actual cosmic sources from
noise and now we want to measure these cosmic sources. What are their
positions and what are their flux densities?</p>
<p>Again, the algorithms from <code>scipy.ndimage</code> help us to
determine these quantities. This is the CPU code for measuring our
sources.</p>
<div class="codewrapper sourceCode" id="cb44">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.ndimage <span class="im">import</span> center_of_mass <span class="im">as</span> com_cpu</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.ndimage <span class="im">import</span> sum_labels <span class="im">as</span> sl_cpu</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>all_positions <span class="op">=</span> com_cpu(data, labelled_image, <span class="op">\</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>                               <span class="bu">range</span>(<span class="dv">1</span>, number_of_sources_in_image<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>all_integrated_fluxes <span class="op">=</span> sl_cpu(data, labelled_image, <span class="op">\</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>                               <span class="bu">range</span>(<span class="dv">1</span>, number_of_sources_in_image<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="ss">f'These are the ten highest integrated fluxes of the sources in my </span><span class="ch">\n\</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a><span class="ss">image: </span><span class="sc">{</span>np<span class="sc">.</span>sort(all_integrated_fluxes)[<span class="op">-</span><span class="dv">10</span>:]<span class="sc">}</span><span class="ss">'</span>)</span></code></pre>
</div>
<p>which gives the Galactic Center as the most luminous source, which
makes sense when we look at our image.</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>These are the ten highest integrated fluxes of the sources in my image: [ 38.90615184  41.91485894  43.02203498  47.30590784  51.23707351
  58.07289425  68.85673917  70.31223921  95.16443585 363.58937774]</code></pre>
</div>
<p>Now we can try to measure the execution times for both algorithms,
like this:</p>
<div class="codewrapper sourceCode" id="cb46">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>timeit <span class="op">-</span>o</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>all_positions <span class="op">=</span> com_cpu(data, labelled_image, <span class="op">\</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>                               <span class="bu">range</span>(<span class="dv">1</span>, number_of_sources_in_image<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>all_integrated_fluxes <span class="op">=</span> sl_cpu(data, labelled_image, <span class="op">\</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>                               <span class="bu">range</span>(<span class="dv">1</span>, number_of_sources_in_image<span class="op">+</span><span class="dv">1</span>))</span></code></pre>
</div>
<p>Which yields, on my machine:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>797 ms ± 9.32 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&lt;TimeitResult : 797 ms ± 9.32 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)&gt;</code></pre>
</div>
<p>To collect the result from that timing in our next cell block, we
need a trick that uses the <code>_</code> variable.</p>
<div class="codewrapper sourceCode" id="cb48">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>timing_source_measurements_CPU <span class="op">=</span> _</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>fastest_source_measurements_CPU <span class="op">=</span> timing_source_measurements_CPU.best</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Fastest CPU set of source measurements = </span><span class="ch">\</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a><span class="sc">{</span><span class="dv">1000</span> <span class="op">*</span> fastest_source_measurements_CPU<span class="sc">:.3e}</span><span class="ss"> ms."</span>)</span></code></pre>
</div>
<p>Which yields</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Fastest CPU set of source measurements = 7.838e+02 ms.</code></pre>
</div>
<div id="challenge-putting-it-all-together" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-putting-it-all-together" class="callout-inner">
<h3 class="callout-title">Challenge: putting it all together<a class="anchor" aria-label="anchor" href="#challenge-putting-it-all-together"></a>
</h3>
<div class="callout-content">
<p>Combine the first two steps of image processing for astronomy,
i.e. determining background characteristics e.g. through <span class="math inline">\(\kappa, \sigma\)</span> clipping and segmentation
into a single function, that works for both CPU and GPU. Next, write a
function for connected component labelling and source measurements on
the GPU and calculate the overall speedup factor for the combined four
steps of image processing in astronomy on the GPU relative to the CPU.
Finally, verify your output by comparing with the previous output, using
the CPU.</p>
</div>
</div>
</div>
<div id="accordionSolution4" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution4" aria-expanded="false" aria-controls="collapseSolution4">
  <h4 class="accordion-header" id="headingSolution4">
  Show me the solution
  </h4>
</button>
<div id="collapseSolution4" class="accordion-collapse collapse" data-bs-parent="#accordionSolution4" aria-labelledby="headingSolution4">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb50">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> first_two_steps_for_both_CPU_and_GPU(data):</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>    data_flat <span class="op">=</span> data.ravel()</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>    data_clipped <span class="op">=</span> kappa_sigma_clipper(data_flat)</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    stddev_ <span class="op">=</span> np.std(data_clipped)</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>    threshold <span class="op">=</span> <span class="dv">5</span> <span class="op">*</span> stddev_</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>    segmented_image <span class="op">=</span> np.where(data <span class="op">&gt;</span> threshold, <span class="dv">1</span>,  <span class="dv">0</span>)</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> segmented_image</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ccl_and_source_measurements_on_CPU(data_CPU, segmented_image_CPU):</span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>    labelled_image_CPU <span class="op">=</span> np.empty(data_CPU.shape)</span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>    number_of_sources_in_image <span class="op">=</span> label_cpu(segmented_image_CPU, </span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>                                       output<span class="op">=</span> labelled_image_CPU)</span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>    all_positions <span class="op">=</span> com_cpu(data_CPU, labelled_image_CPU, </span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a>                            np.arange(<span class="dv">1</span>, number_of_sources_in_image<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a>    all_fluxes <span class="op">=</span> sl_cpu(data_CPU, labelled_image_CPU, </span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a>                            np.arange(<span class="dv">1</span>, number_of_sources_in_image<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(all_positions), np.array(all_fluxes)</span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true" tabindex="-1"></a>CPU_output <span class="op">=</span> ccl_and_source_measurements_on_CPU(data, <span class="op">\</span></span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true" tabindex="-1"></a>                 first_two_steps_for_both_CPU_and_GPU(data))</span>
<span id="cb50-21"><a href="#cb50-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-22"><a href="#cb50-22" aria-hidden="true" tabindex="-1"></a>timing_complete_processing_CPU <span class="op">=</span>  <span class="op">\</span></span>
<span id="cb50-23"><a href="#cb50-23" aria-hidden="true" tabindex="-1"></a>    benchmark(ccl_and_source_measurements_on_CPU, (data, <span class="op">\</span></span>
<span id="cb50-24"><a href="#cb50-24" aria-hidden="true" tabindex="-1"></a>       first_two_steps_for_both_CPU_and_GPU(data)), <span class="op">\</span></span>
<span id="cb50-25"><a href="#cb50-25" aria-hidden="true" tabindex="-1"></a>       n_repeat<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb50-26"><a href="#cb50-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-27"><a href="#cb50-27" aria-hidden="true" tabindex="-1"></a>fastest_complete_processing_CPU <span class="op">=</span> <span class="op">\</span></span>
<span id="cb50-28"><a href="#cb50-28" aria-hidden="true" tabindex="-1"></a>    np.amin(timing_complete_processing_CPU.cpu_times)</span>
<span id="cb50-29"><a href="#cb50-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-30"><a href="#cb50-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The four steps of image processing for astronomy take </span><span class="ch">\</span></span>
<span id="cb50-31"><a href="#cb50-31" aria-hidden="true" tabindex="-1"></a><span class="sc">{</span><span class="dv">1000</span> <span class="op">*</span> fastest_complete_processing_CPU<span class="sc">:.3e}</span><span class="ss"> ms</span><span class="ch">\n</span><span class="ss"> on our CPU."</span>)</span>
<span id="cb50-32"><a href="#cb50-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-33"><a href="#cb50-33" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> cupyx.scipy.ndimage <span class="im">import</span> label <span class="im">as</span> label_gpu</span>
<span id="cb50-34"><a href="#cb50-34" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> cupyx.scipy.ndimage <span class="im">import</span> center_of_mass <span class="im">as</span> com_gpu</span>
<span id="cb50-35"><a href="#cb50-35" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> cupyx.scipy.ndimage <span class="im">import</span> sum_labels <span class="im">as</span> sl_gpu</span>
<span id="cb50-36"><a href="#cb50-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-37"><a href="#cb50-37" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ccl_and_source_measurements_on_GPU(data_GPU, segmented_image_GPU):</span>
<span id="cb50-38"><a href="#cb50-38" aria-hidden="true" tabindex="-1"></a>    labelled_image_GPU <span class="op">=</span> cp.empty(data_GPU.shape)</span>
<span id="cb50-39"><a href="#cb50-39" aria-hidden="true" tabindex="-1"></a>    number_of_sources_in_image <span class="op">=</span> label_gpu(segmented_image_GPU, </span>
<span id="cb50-40"><a href="#cb50-40" aria-hidden="true" tabindex="-1"></a>                                           output<span class="op">=</span> labelled_image_GPU)</span>
<span id="cb50-41"><a href="#cb50-41" aria-hidden="true" tabindex="-1"></a>    all_positions <span class="op">=</span> com_gpu(data_GPU, labelled_image_GPU, </span>
<span id="cb50-42"><a href="#cb50-42" aria-hidden="true" tabindex="-1"></a>                            cp.arange(<span class="dv">1</span>, number_of_sources_in_image<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb50-43"><a href="#cb50-43" aria-hidden="true" tabindex="-1"></a>    all_fluxes <span class="op">=</span> sl_gpu(data_GPU, labelled_image_GPU, </span>
<span id="cb50-44"><a href="#cb50-44" aria-hidden="true" tabindex="-1"></a>                            cp.arange(<span class="dv">1</span>, number_of_sources_in_image<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb50-45"><a href="#cb50-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This seems redundant, but we want to return ndarrays (Numpy)</span></span>
<span id="cb50-46"><a href="#cb50-46" aria-hidden="true" tabindex="-1"></a>    <span class="co"># and what we have are lists. These first have to be converted to</span></span>
<span id="cb50-47"><a href="#cb50-47" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Cupy arrays before they can be converted to Numpy arrays.</span></span>
<span id="cb50-48"><a href="#cb50-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cp.asnumpy(cp.asarray(all_positions)), <span class="op">\</span></span>
<span id="cb50-49"><a href="#cb50-49" aria-hidden="true" tabindex="-1"></a>           cp.asnumpy(cp.asarray(all_fluxes))</span>
<span id="cb50-50"><a href="#cb50-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-51"><a href="#cb50-51" aria-hidden="true" tabindex="-1"></a>GPU_output <span class="op">=</span> ccl_and_source_measurements_on_GPU(cp.asarray(data), <span class="op">\</span></span>
<span id="cb50-52"><a href="#cb50-52" aria-hidden="true" tabindex="-1"></a>                 first_two_steps_for_both_CPU_and_GPU(cp.asarray(data)))</span>
<span id="cb50-53"><a href="#cb50-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-54"><a href="#cb50-54" aria-hidden="true" tabindex="-1"></a>timing_complete_processing_GPU <span class="op">=</span>  <span class="op">\</span></span>
<span id="cb50-55"><a href="#cb50-55" aria-hidden="true" tabindex="-1"></a>    benchmark(ccl_and_source_measurements_on_GPU, (cp.asarray(data), <span class="op">\</span></span>
<span id="cb50-56"><a href="#cb50-56" aria-hidden="true" tabindex="-1"></a>       first_two_steps_for_both_CPU_and_GPU(cp.asarray(data))), <span class="op">\</span></span>
<span id="cb50-57"><a href="#cb50-57" aria-hidden="true" tabindex="-1"></a>       n_repeat<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb50-58"><a href="#cb50-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-59"><a href="#cb50-59" aria-hidden="true" tabindex="-1"></a>fastest_complete_processing_GPU <span class="op">=</span> <span class="op">\</span></span>
<span id="cb50-60"><a href="#cb50-60" aria-hidden="true" tabindex="-1"></a>    np.amin(timing_complete_processing_GPU.gpu_times)</span>
<span id="cb50-61"><a href="#cb50-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-62"><a href="#cb50-62" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The four steps of image processing for astronomy take </span><span class="ch">\</span></span>
<span id="cb50-63"><a href="#cb50-63" aria-hidden="true" tabindex="-1"></a><span class="sc">{</span><span class="dv">1000</span> <span class="op">*</span> fastest_complete_processing_GPU<span class="sc">:.3e}</span><span class="ss"> ms</span><span class="ch">\n</span><span class="ss"> on our GPU."</span>)</span>
<span id="cb50-64"><a href="#cb50-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-65"><a href="#cb50-65" aria-hidden="true" tabindex="-1"></a>overall_speedup_factor <span class="op">=</span> fastest_complete_processing_CPU<span class="op">/</span> <span class="op">\</span></span>
<span id="cb50-66"><a href="#cb50-66" aria-hidden="true" tabindex="-1"></a>                         fastest_complete_processing_GPU</span>
<span id="cb50-67"><a href="#cb50-67" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"This means that the overall speedup factor GPU vs CPU equals: </span><span class="ch">\</span></span>
<span id="cb50-68"><a href="#cb50-68" aria-hidden="true" tabindex="-1"></a><span class="sc">{</span>overall_speedup_factor<span class="sc">:.3e}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb50-69"><a href="#cb50-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-70"><a href="#cb50-70" aria-hidden="true" tabindex="-1"></a>all_positions_agree <span class="op">=</span> np.allclose(CPU_output[<span class="dv">0</span>], GPU_output[<span class="dv">0</span>])</span>
<span id="cb50-71"><a href="#cb50-71" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The CPU and GPU positions agree: </span><span class="sc">{</span>all_positions_agree<span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb50-72"><a href="#cb50-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-73"><a href="#cb50-73" aria-hidden="true" tabindex="-1"></a>all_fluxes_agree <span class="op">=</span> np.allclose(CPU_output[<span class="dv">1</span>], GPU_output[<span class="dv">1</span>])</span>
<span id="cb50-74"><a href="#cb50-74" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The CPU and GPU fluxes agree: </span><span class="sc">{</span>all_positions_agree<span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>The four steps of image processing for astronomy take 1.060e+03 ms 
 on our CPU.
The four steps of image processing for astronomy take 5.770e+01 ms 
 on our GPU.
This means that the overall speedup factor GPU vs CPU equals: 1.838e+01

The CPU and GPU positions agree: True

The CPU and GPU fluxes agree: True</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Keypoints<a class="anchor" aria-label="anchor" href="#keypoints1"></a>
</h3>
<div class="callout-content">
<ul><li>“CuPy provides GPU accelerated version of many NumPy and Scipy
functions.”</li>
<li>“Always have CPU and GPU versions of your code so that you can
compare performance, as well as validate your code.”</li>
</ul></div>
</div>
</div>
<!-- 
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use. 
 -->
</div>



      </div> <!-- / div.lesson-content -->
    </main><!-- / main#main-content.main-content --><nav class="bottom-pagination mx-md-4" aria-label="Previous and Next Chapter"><div class="d-block d-sm-block d-md-none">
        <a class="chapter-link" href="introduction.html"><i aria-hidden="true" class="small-arrow" data-feather="arrow-left"></i>Previous</a>
        <a class="chapter-link float-end" href="numba.html">Next<i aria-hidden="true" class="small-arrow" data-feather="arrow-right"></i></a>
      </div>
      <!-- content for large screens -->
      <div class="d-none d-sm-none d-md-block">
        <a class="chapter-link" href="introduction.html" rel="prev"><i aria-hidden="true" class="small-arrow" data-feather="arrow-left"></i>Previous: Introduction</a>
        <a class="chapter-link float-end" href="numba.html" rel="next">Next: Accelerate your... <i aria-hidden="true" class="small-arrow" data-feather="arrow-right"></i></a>
      </div>
    </nav></div> <!-- / div.primary-content.col-xs-12 -->
<!-- END:   inst/pkgdown/templates/content-instructor.html-->

      </div><!--/div.row-->
      		<footer class="row footer mx-md-3"><hr><div class="col-md-6">
				<p>This lesson is subject to the <a href="CODE_OF_CONDUCT.html">Code of Conduct</a></p>
        <p>
        
        <a href="https://github.com/carpentries-incubator/lesson-gpu-programming/edit/main/episodes/cupy.Rmd" class="external-link">Edit on GitHub</a>
        
	
        | <a href="https://github.com/carpentries-incubator/lesson-gpu-programming/blob/main/CONTRIBUTING.md" class="external-link">Contributing</a> 
        | <a href="https://github.com/carpentries-incubator/lesson-gpu-programming/" class="external-link">Source</a></p>
				<p><a href="https://github.com/carpentries-incubator/lesson-gpu-programming/blob/main/CITATION" class="external-link">Cite</a> | <a href="mailto:instructors@esciencecenter.nl">Contact</a> | <a href="https://carpentries.org/about/" class="external-link">About</a></p>
			</div>
			<div class="col-md-6">
        
        <p>Materials licensed under <a href="LICENSE.html">CC-BY 4.0</a> by the authors</p>
        
        <p><a href="https://creativecommons.org/licenses/by-sa/4.0/" class="external-link">Template licensed under CC-BY 4.0</a> by <a href="https://carpentries.org" class="external-link">The Carpentries</a></p>
        <p>Built with <a href="https://github.com/carpentries/sandpaper" class="external-link">sandpaper (0.12.5)</a>,
        <a href="https://github.com/carpentries/pegboard" class="external-link">pegboard (0.5.3)</a>,
      and <a href="https://github.com/carpentries/varnish/tree/0.2.17" class="external-link">varnish (0.2.17)</a>.</p>
			</div>
		</footer></div> <!-- / div.container -->
	<div id="to-top">
		<a href="#top">
			<i class="search-icon" data-feather="arrow-up" role="img" aria-label="Back to top"></i><br><span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top
		</a>
	</div>
  <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "TrainingMaterial",
  "@id": "https://carpentries-incubator.github.io/lesson-gpu-programming/cupy.html",
  "dct:conformsTo": "https://bioschemas.org/profiles/TrainingMaterial/1.0-RELEASE",
  "description": "A Carpentries Lesson teaching foundational data and coding skills to researchers worldwide",
  "keywords": "high-performance computing, HPC, graphics processing units, GPU",
  "name": "Using your GPU with CuPy",
  "creativeWorkStatus": "active",
  "url": "https://carpentries-incubator.github.io/lesson-gpu-programming/cupy.html",
  "identifier": "https://carpentries-incubator.github.io/lesson-gpu-programming/cupy.html",
  "dateCreated": "2020-09-25",
  "dateModified": "2023-07-11",
  "datePublished": "2023-07-18"
}

  </script><script>
		feather.replace();
	</script><!-- Matomo
    2022-11-07: we have gotten a notification that we have an overage for our
    tracking and I'm pretty sure this has to do with Workbench usage.
    Considering that I am not _currently_ using this tracking because I do not
    yet know how to access the data, I am turning this off for now.
  <script>
    var _paq = window._paq = window._paq || [];
    /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
    _paq.push(["setDocumentTitle", document.domain + "/" + document.title]);
    _paq.push(["setDomains", ["*.preview.carpentries.org","*.datacarpentry.github.io","*.datacarpentry.org","*.librarycarpentry.github.io","*.librarycarpentry.org","*.swcarpentry.github.io", "*.carpentries.github.io"]]);
    _paq.push(["setDoNotTrack", true]);
    _paq.push(["disableCookies"]);
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
          var u="https://carpentries.matomo.cloud/";
          _paq.push(['setTrackerUrl', u+'matomo.php']);
          _paq.push(['setSiteId', '1']);
          var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
          g.async=true; g.src='https://cdn.matomo.cloud/carpentries.matomo.cloud/matomo.js'; s.parentNode.insertBefore(g,s);
        })();
  </script>
  End Matomo Code --></body></html><!-- END:   inst/pkgdown/templates/layout.html-->

