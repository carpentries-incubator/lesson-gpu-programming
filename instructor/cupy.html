<!DOCTYPE html>
<!-- START: inst/pkgdown/templates/layout.html --><!-- Generated by pkgdown: do not edit by hand --><html lang="en" data-bs-theme="auto"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><title>GPU Programming: Using your GPU with CuPy</title><meta name="viewport" content="width=device-width, initial-scale=1"><script src="../assets/themetoggle.js"></script><link rel="stylesheet" type="text/css" href="../assets/styles.css"><script src="../assets/scripts.js" type="text/javascript"></script><!-- mathjax --><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      config: ["MMLorHTML.js"],
      jax: ["input/TeX","input/MathML","output/HTML-CSS","output/NativeMML", "output/PreviewHTML"],
      extensions: ["tex2jax.js","mml2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
      TeX: {
        extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
      },
      tex2jax: {
        inlineMath: [['\\(', '\\)']],
        displayMath: [ ['$$','$$'], ['\\[', '\\]'] ],
        processEscapes: true
      }
    });
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><!-- Responsive Favicon for The Carpentries --><link rel="apple-touch-icon" sizes="180x180" href="../favicons/incubator/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="../favicons/incubator/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="../favicons/incubator/favicon-16x16.png"><link rel="manifest" href="../favicons/incubator/site.webmanifest"><link rel="mask-icon" href="../favicons/incubator/safari-pinned-tab.svg" color="#5bbad5"><meta name="msapplication-TileColor" content="#da532c"><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="black"></head><body>
    <header id="top" class="navbar navbar-expand-md top-nav incubator"><svg xmlns="http://www.w3.org/2000/svg" class="d-none"><symbol id="check2" viewbox="0 0 16 16"><path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"></path></symbol><symbol id="circle-half" viewbox="0 0 16 16"><path d="M8 15A7 7 0 1 0 8 1v14zm0 1A8 8 0 1 1 8 0a8 8 0 0 1 0 16z"></path></symbol><symbol id="moon-stars-fill" viewbox="0 0 16 16"><path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path><path d="M10.794 3.148a.217.217 0 0 1 .412 0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217 0 0 1 0 .412l-1.162.387a1.734 1.734 0 0 0-1.097 1.097l-.387 1.162a.217.217 0 0 1-.412 0l-.387-1.162A1.734 1.734 0 0 0 9.31 6.593l-1.162-.387a.217.217 0 0 1 0-.412l1.162-.387a1.734 1.734 0 0 0 1.097-1.097l.387-1.162zM13.863.099a.145.145 0 0 1 .274 0l.258.774c.115.346.386.617.732.732l.774.258a.145.145 0 0 1 0 .274l-.774.258a1.156 1.156 0 0 0-.732.732l-.258.774a.145.145 0 0 1-.274 0l-.258-.774a1.156 1.156 0 0 0-.732-.732l-.774-.258a.145.145 0 0 1 0-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"></path></symbol><symbol id="sun-fill" viewbox="0 0 16 16"><path d="M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"></path></symbol></svg><a class="visually-hidden-focusable skip-link" href="#main-content">Skip to main content</a>
  <div class="container-fluid top-nav-container">
    <div class="col-md-8">
      <div class="large-logo">
        <img id="incubator-logo" alt="Carpentries Incubator" src="../assets/images/incubator-logo.svg"><span class="badge text-bg-info">
          <abbr title="This lesson is in the beta phase, which means that it is ready for teaching by instructors outside of the original author team.">
            <a href="https://cdh.carpentries.org/the-lesson-life-cycle.html#polishing-beta-stage" class="external-link alert-link">
              <i aria-hidden="true" class="icon" data-feather="alert-circle" style="border-radius: 5px"></i>
              Beta
            </a>
            <span class="visually-hidden">This lesson is in the beta phase, which means that it is ready for teaching by instructors outside of the original author team.</span>
          </abbr>
        </span>

      </div>
    </div>
    <div class="selector-container">
      <div id="theme-selector">
        <li class="nav-item dropdown" id="theme-button-list">
          <button class="btn btn-link nav-link px-0 px-lg-2 dropdown-toggle d-flex align-items-center" id="bd-theme" type="button" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme (auto)">
            <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg><i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="bd-theme-text"><li>
              <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                <svg class="bi me-2 theme-icon"><use href="#sun-fill"></use></svg>
                Light
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
            <li>
              <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                <svg class="bi me-2 theme-icon"><use href="#moon-stars-fill"></use></svg>
                Dark
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
            <li>
              <button type="button" class="btn dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
                <svg class="bi me-2 theme-icon"><use href="#circle-half"></use></svg>
                Auto
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
          </ul></li>
      </div>

      <div class="dropdown" id="instructor-dropdown">
        <button class="btn btn-secondary dropdown-toggle bordered-button" type="button" id="dropdownMenu1" data-bs-toggle="dropdown" aria-expanded="false">
          <i aria-hidden="true" class="icon" data-feather="eye"></i> Instructor View <i data-feather="chevron-down"></i>
        </button>
        <ul class="dropdown-menu" aria-labelledby="dropdownMenu1"><li><button class="dropdown-item" type="button" onclick="window.location.href='../cupy.html';">Learner View</button></li>
        </ul></div>
    </div>
  </div>
  <hr></header><nav class="navbar navbar-expand-xl bottom-nav incubator" aria-label="Main Navigation"><div class="container-fluid nav-container">
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle Navigation">
      <span class="navbar-toggler-icon"></span>
      <span class="menu-title">Menu</span>
    </button>
    <div class="nav-logo">
      <img class="small-logo" alt="Carpentries Incubator" src="../assets/images/incubator-logo-sm.svg"></div>
    <div class="lesson-title-md">
      GPU Programming
    </div>
    <div class="search-icon-sm">
      <!-- TODO: do not show until we have search
        <i role="img" aria-label="Search the All In One page" data-feather="search"></i>
      -->
    </div>
    <div class="desktop-nav">
      <ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item">
          <span class="lesson-title">
            GPU Programming
          </span>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../instructor/key-points.html">Key Points</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../instructor/instructor-notes.html">Instructor Notes</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../instructor/images.html">Extract All Images</a>
        </li>
        <li class="nav-item dropdown">
          <button class="nav-link dropdown-toggle" id="navbarDropdown" data-bs-toggle="dropdown" aria-expanded="false">
            More <i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu" aria-labelledby="navbarDropdown"><hr><li><a class="dropdown-item" href="reference.html">Reference</a></li>
          </ul></li>
      </ul></div>
    <!--
    <form class="d-flex col-md-2 search-form">
      <fieldset disabled>
      <input class="form-control me-2 searchbox" type="search" placeholder="" aria-label="">
        <button class="btn btn-outline-success tablet-search-button"  type="submit">
          <i class="search-icon" data-feather="search" role="img" aria-label="Search the All In One page"></i>
        </button>
      </fieldset>
    </form>
    -->
    <a id="search-button" class="btn btn-primary" href="../instructor/aio.html" role="button" aria-label="Search the All In One page">Search the All In One page</a>
  </div><!--/div.container-fluid -->
</nav><div class="col-md-12 mobile-title">
  GPU Programming
</div>

<aside class="col-md-12 lesson-progress"><div style="width: 2%" class="percentage">
    2%
  </div>
  <div class="progress incubator">
    <div class="progress-bar incubator" role="progressbar" style="width: 2%" aria-valuenow="2" aria-label="Lesson Progress" aria-valuemin="0" aria-valuemax="100">
    </div>
  </div>
</aside><div class="container">
      <div class="row">
        <!-- START: inst/pkgdown/templates/navbar.html -->
<div id="sidebar-col" class="col-lg-4">
  <div id="sidebar" class="sidebar">
      <nav aria-labelledby="flush-headingEleven"><button role="button" aria-label="close menu" alt="close menu" aria-expanded="true" aria-controls="sidebar" class="collapse-toggle" data-collapse="Collapse " data-episodes="Episodes ">
          <i class="search-icon" data-feather="x" role="img"></i>
        </button>
        <div class="sidebar-inner">
          <div class="row mobile-row" id="theme-row-mobile">
            <div class="col" id="theme-selector">
              <li class="nav-item dropdown" id="theme-button-list">
                <button class="btn btn-link nav-link px-0 px-lg-2 dropdown-toggle d-flex align-items-center" id="bd-theme" type="button" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme (auto)">
                  <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg><span class="d-lg-none ms-1" id="bd-theme-text">Toggle Theme</span>
                </button>
                <ul class="dropdown-menu dropdown-menu-right" aria-labelledby="bd-theme-text"><li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                      <svg class="bi me-2 theme-icon"><use href="#sun-fill"></use></svg>
                      Light
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                  <li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                      <svg class="bi me-2 theme-icon"><use href="#moon-stars-fill"></use></svg>
                      Dark
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                  <li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
                      <svg class="bi me-2 theme-icon"><use href="#circle-half"></use></svg>
                      Auto
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                </ul></li>
            </div>
          </div>
          <div class="row mobile-row">
            <div class="col">
              <div class="sidenav-view-selector">
                <div class="accordion accordion-flush" id="accordionFlush9">
                  <div class="accordion-item">
                    <h2 class="accordion-header" id="flush-headingNine">
                      <button class="accordion-button collapsed" id="instructor" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseNine" aria-expanded="false" aria-controls="flush-collapseNine">
                        <i id="eye" aria-hidden="true" class="icon" data-feather="eye"></i> Instructor View
                      </button>
                    </h2>
                    <div id="flush-collapseNine" class="accordion-collapse collapse" aria-labelledby="flush-headingNine" data-bs-parent="#accordionFlush2">
                      <div class="accordion-body">
                        <a href="../cupy.html">Learner View</a>
                      </div>
                    </div>
                  </div><!--/div.accordion-item-->
                </div><!--/div.accordion-flush-->
              </div><!--div.sidenav-view-selector -->
            </div><!--/div.col -->

            <hr></div><!--/div.mobile-row -->

          <div class="accordion accordion-flush" id="accordionFlush11">
            <div class="accordion-item">

              <button id="chapters" class="accordion-button show" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseEleven" aria-expanded="false" aria-controls="flush-collapseEleven">
                <h2 class="accordion-header chapters" id="flush-headingEleven">
                  EPISODES
                </h2>
              </button>
              <div id="flush-collapseEleven" class="accordion-collapse show collapse" aria-labelledby="flush-headingEleven" data-bs-parent="#accordionFlush11">

                <div class="accordion-body">
                  <div class="accordion accordion-flush" id="accordionFlush1">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading1">
        <a href="index.html">Summary and Schedule</a>
    </div><!--/div.accordion-header-->

  </div><!--/div.accordion-item-->
</div><!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush2">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading2">
        <a href="introduction.html">1. Introduction</a>
    </div><!--/div.accordion-header-->

  </div><!--/div.accordion-item-->
</div><!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlushcurrent">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-headingcurrent">
        <span class="visually-hidden">Current Chapter</span>
        <span class="current-chapter">
        2. Using your GPU with CuPy
        </span>
      
    </div><!--/div.accordion-header-->

  </div><!--/div.accordion-item-->
</div><!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush4">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading4">
        <a href="numba.html">3. Accelerate your Python code with Numba</a>
    </div><!--/div.accordion-header-->

  </div><!--/div.accordion-item-->
</div><!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush5">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading5">
        <a href="gpu_introduction.html">4. A Better Look at the GPU</a>
    </div><!--/div.accordion-header-->

  </div><!--/div.accordion-item-->
</div><!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush6">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading6">
        <a href="first_program.html">5. Your First GPU Kernel</a>
    </div><!--/div.accordion-header-->

  </div><!--/div.accordion-item-->
</div><!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush7">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading7">
        <a href="global_local_memory.html">6. Registers, Global, and Local Memory</a>
    </div><!--/div.accordion-header-->

  </div><!--/div.accordion-item-->
</div><!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush8">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading8">
        <a href="shared_memory_and_synchronization.html">7. Shared Memory and Synchronization</a>
    </div><!--/div.accordion-header-->

  </div><!--/div.accordion-item-->
</div><!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush9">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading9">
        <a href="constant_memory.html">8. Constant Memory</a>
    </div><!--/div.accordion-header-->

  </div><!--/div.accordion-item-->
</div><!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush10">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading10">
        <a href="streams.html">9. Concurrent access to the GPU</a>
    </div><!--/div.accordion-header-->

  </div><!--/div.accordion-item-->
</div><!--/div.accordion-flush-->

                </div>
              </div>
            </div>

            <hr class="half-width"><div class="accordion accordion-flush lesson-resources" id="accordionFlush12">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-headingTwelve">
                  <button class="accordion-button collapsed" id="lesson-resources" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseTwelve" aria-expanded="false" aria-controls="flush-collapseTwelve">
                    RESOURCES
                  </button>
                </h2>
                <div id="flush-collapseTwelve" class="accordion-collapse collapse" aria-labelledby="flush-headingTwelve" data-bs-parent="#accordionFlush12">
                  <div class="accordion-body">
                    <ul><li>
                        <a href="../instructor/key-points.html">Key Points</a>
                      </li>
                      <li>
                        <a href="../instructor/instructor-notes.html">Instructor Notes</a>
                      </li>
                      <li>
                        <a href="../instructor/images.html">Extract All Images</a>
                      </li>
                      <hr><li><a class="dropdown-item" href="reference.html">Reference</a></li>
                    </ul></div>
                </div>
              </div>
            </div>
            <hr class="half-width lesson-resources"><a href="../instructor/aio.html">See all in one page</a>


            <hr class="d-none d-sm-block d-md-none"><div class="d-grid gap-1">

            </div>
          </div><!-- /div.accordion -->
        </div><!-- /div.sidebar-inner -->
      </nav></div><!-- /div.sidebar -->
  </div><!-- /div.sidebar-col -->
<!-- END:   inst/pkgdown/templates/navbar.html-->

        <!-- START: inst/pkgdown/templates/content-instructor.html -->
  <div class="col-xl-8 col-lg-12 primary-content">
    <nav class="lesson-content mx-md-4" aria-label="Previous and Next Chapter"><!-- content for small screens --><div class="d-block d-sm-block d-md-none">
        <a class="chapter-link" href="../instructor/introduction.html"><i aria-hidden="true" class="small-arrow" data-feather="arrow-left"></i>Previous</a>
        <a class="chapter-link float-end" href="../instructor/numba.html">Next<i aria-hidden="true" class="small-arrow" data-feather="arrow-right"></i></a>
      </div>
      <!-- content for large screens -->
      <div class="d-none d-sm-none d-md-block">
        <a class="chapter-link" href="../instructor/introduction.html" rel="prev">
          <i aria-hidden="true" class="small-arrow" data-feather="arrow-left"></i>
          Previous: Introduction
        </a>
        <a class="chapter-link float-end" href="../instructor/numba.html" rel="next">
          Next: Accelerate your...
          <i aria-hidden="true" class="small-arrow" data-feather="arrow-right"></i>
        </a>
      </div>
      <hr></nav><main id="main-content" class="main-content"><div class="container lesson-content">
        <h1>Using your GPU with CuPy</h1>
        <p>Last updated on 2024-11-04 |

        <a href="https://github.com/carpentries-incubator/lesson-gpu-programming/edit/main/episodes/cupy.Rmd" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>



        <p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 270 minutes</p>

        <div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>

        

<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul><li>“How can I increase the performance of code that uses NumPy?”</li>
<li>“How can I copy NumPy arrays to the GPU?”</li>
</ul></div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul><li>“Be able to indicate if an array, represented by a variable in an
iPython shell, is stored in host or device memory.”</li>
<li>“Be able to copy the contents of this array from host to device
memory and vice versa.”</li>
<li>“Be able to select the appropriate function to either convolve an
image using either CPU or GPU compute power.”</li>
<li>“Be able to quickly estimate the speed benefits for a simple
calculation by moving it from the CPU to the GPU.”</li>
</ul></div>
</div>
</div>
</div>
</div>
<div class="section level1">
<h1 id="introduction-to-cupy">Introduction to CuPy<a class="anchor" aria-label="anchor" href="#introduction-to-cupy"></a></h1>
<p><a href="https://cupy.dev" class="external-link">CuPy</a> is a GPU array library that
implements a subset of the NumPy and SciPy interfaces. Thanks to CuPy,
people conversant with NumPy can very conveniently harvest the compute
power of GPUs without writing code in GPU programming languages such as
CUDA, OpenCL, and HIP.</p>
<p>From now on we can also use the word <em>host</em> to refer to the
CPU on the laptop, desktop, or cluster node you are using as usual, and
<em>device</em> to refer to the graphics card and its GPU.</p>
</div>
<div class="section level1">
<h1 id="convolutions-in-python">Convolutions in Python<a class="anchor" aria-label="anchor" href="#convolutions-in-python"></a></h1>
<p>We start by generating an image using Python and NumPy code. We want
to compute a convolution on this input image once on the host and once
on the device, and then compare both the execution times and the
results.</p>
<p>In an iPython shell or a Jupyter notebook, we can write and execute
the following code on the host. The pixel values will be zero everywhere
except for a regular grid of single pixels having value one, very much
like a Dirac’s delta function; hence the input image is named
<code>deltas</code>.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="co"># Construct an image with repeated delta functions</span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>diracs <span class="op">=</span> np.zeros((<span class="dv">2048</span>, <span class="dv">2048</span>))</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>diracs[<span class="dv">8</span>::<span class="dv">16</span>,<span class="dv">8</span>::<span class="dv">16</span>] <span class="op">=</span> <span class="dv">1</span></span></code></pre>
</div>
<p>We can display the top-left corner of the input image to get a
feeling of how it looks like, as follows:</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="im">import</span> pylab <span class="im">as</span> pyl</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="co"># Jupyter 'magic' command to render a Matplotlib image in the notebook</span></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a><span class="co"># Display the image</span></span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a><span class="co"># You can zoom in/out using the menu in the window that will appear</span></span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a>pyl.imshow(diracs[<span class="dv">0</span>:<span class="dv">32</span>, <span class="dv">0</span>:<span class="dv">32</span>])</span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>pyl.show()</span></code></pre>
</div>
<p>and you should obtain the following image:</p>
<figure><img src=".././fig/diracs.png" alt="Grid of delta functions." class="figure mx-auto d-block"><div class="figcaption">Grid of delta functions</div>
</figure><div class="section level2">
<h2 id="gaussian-convolutions">Gaussian convolutions<a class="anchor" aria-label="anchor" href="#gaussian-convolutions"></a></h2>
<p>The illustration below shows an example of convolution (courtesy of
Michael Plotke, CC BY-SA 3.0, via Wikimedia Commons). Looking at the
terminology in the illustration, be forewarned that the word
<em>kernel</em> happens to have different meanings that, inconveniently,
apply to both mathematical convolution and coding on a GPU device. To
know more about convolutions, we encourage you to check out <a href="https://github.com/vdumoulin/conv_arithmetic" class="external-link">this GitHub
repository</a> by Vincent Dumoulin and Francesco Visin with some great
animations.</p>
<figure><img src=".././fig/2D_Convolution_Animation.gif" alt="Example of animated convolution" class="figure mx-auto d-block"><div class="figcaption">Example of animated convolution.</div>
</figure><p>In this course section, we will convolve our image with a 2D Gaussian
function, having the general form:</p>
<p><span class="math display">\[G(x,y) = \frac{1}{2\pi \sigma^2}
\exp\left(-\frac{x^2 + y^2}{2 \sigma^2}\right)\]</span></p>
<p>where <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> are distances from the origin, and
<span class="math inline">\(\sigma\)</span> controls the width of the
Gaussian curve. Since we can think of an image as a matrix of color
values, the convolution of that image with a kernel generates a new
matrix with different color values. In particular, convolving images
with a 2D Gaussian kernel changes the value of each pixel into a
weighted average of the neighboring pixels, thereby smoothing out the
features in the input image.</p>
<p>Convolutions are frequently used in computer vision to filter images.
For example, Gaussian convolution can be required before applying
algorithms for <a href="https://en.wikipedia.org/wiki/Gaussian_blur#Edge_detection" class="external-link">edge
detection</a>, which are sensitive to the noise in the original image.
To avoid conflicting vocabularies, in the remainder we refer to
<em>convolution kernels</em> as <em>filters</em>.</p>
<div id="callout1" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout</h3>
<div class="callout-content">
<p>Identifying the dataflow inherent in an algorithm is often useful.
Say, if we want to square the numbers in a list, the operations on each
item of the list are independent one of another. The dataflow of a
one-to-one operation is called a <em>map</em>.</p>
<figure><img src=".././fig/mapping.svg" alt="Data flow of a map operation" class="figure mx-auto d-block"><div class="figcaption">Dataflow of a map operation.</div>
</figure><p>A convolution is slightly more complex because of a many-to-one
dataflow, also known as a <em>stencil</em>.</p>
<figure><img src=".././fig/stencil.svg" alt="Data flow of a stencil operation" class="figure mx-auto d-block"><div class="figcaption">Dataflow of a stencil operation.</div>
</figure><p>GPUs are exceptionally well suited to compute algorithms that follow
either dataflow.</p>
</div>
</div>
</div>
</div>
<div class="section level2">
<h2 id="convolution-on-the-cpu-using-scipy">Convolution on the CPU Using SciPy<a class="anchor" aria-label="anchor" href="#convolution-on-the-cpu-using-scipy"></a></h2>
<p>Let’s first construct and then display the Gaussian filter. Remember
that we are still coding everything in standard Python, without using
the GPU.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>x, y <span class="op">=</span> np.meshgrid(np.linspace(<span class="op">-</span><span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">15</span>), np.linspace(<span class="op">-</span><span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">15</span>))</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>dist <span class="op">=</span> np.sqrt(x<span class="op">*</span>x <span class="op">+</span> y<span class="op">*</span>y)</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>sigma <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>origin <span class="op">=</span> <span class="fl">0.000</span></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>gauss <span class="op">=</span> np.exp(<span class="op">-</span>(dist <span class="op">-</span> origin)<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> (<span class="fl">2.0</span> <span class="op">*</span> sigma<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>pyl.imshow(gauss)</span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>pyl.show()</span></code></pre>
</div>
<p>The code above produces this image of a symmetrical two-dimensional
Gaussian:</p>
<figure><img src=".././fig/gauss.png" alt="Two-dimensional Gaussian" class="figure mx-auto d-block"><div class="figcaption">Two-dimensional Gaussian.</div>
</figure><p>Now we are ready to compute the convolution on the host. Very
conveniently, SciPy provides a method for convolutions. Let’s also
record the time to perform this convolution and inspect the top-left
corner of the convolved image, as follows:</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="im">from</span> scipy.signal <span class="im">import</span> convolve2d <span class="im">as</span> convolve2d_cpu</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>convolved_image_cpu <span class="op">=</span> convolve2d_cpu(diracs, gauss)</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>pyl.imshow(convolved_image_cpu[<span class="dv">0</span>:<span class="dv">32</span>, <span class="dv">0</span>:<span class="dv">32</span>])</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>pyl.show()</span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a><span class="op">%</span>timeit <span class="op">-</span>n <span class="dv">1</span> <span class="op">-</span>r <span class="dv">1</span> convolve2d_cpu(diracs, gauss)</span></code></pre>
</div>
<p>Obviously, the compute power of your CPU influences the actual
execution time very much. We expect that to be in the region of a couple
of seconds, as shown in the timing report below:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>2.4 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)</code></pre>
</div>
<p>Displaying just a corner of the image shows that the Gaussian has so
much blurred the original pattern of ones surrounded by zeros that we
end up with a regular pattern of Gaussians.</p>
<figure><img src=".././fig/convolved_image.png" alt="Grid of Gaussians in the convoluted image" class="figure mx-auto d-block"><div class="figcaption">Grid of Gaussians in the convoluted image.</div>
</figure></div>
<div class="section level2">
<h2 id="convolution-on-the-gpu-using-cupy">Convolution on the GPU Using CuPy<a class="anchor" aria-label="anchor" href="#convolution-on-the-gpu-using-cupy"></a></h2>
<p>This is a lesson on GPU programming, so let’s use the GPU. In spite
of being physically connected – typically with special <a href="https://en.wikipedia.org/wiki/Interconnect_(integrated_circuits)" class="external-link">interconnects</a>
– the CPU and the GPU do not share the same memory space. This picture
depicts the different components of CPU and GPU and how they are
connected:</p>
<figure><img src=".././fig/CPU_and_GPU_separated.png" alt="CPU and GPU are separate entities with an own memory" class="figure mx-auto d-block"><div class="figcaption">CPU and GPU are separate entities with an own
memory.</div>
</figure><p>This means that the array created with NumPy is physically stored in
a memory of the host’s and, therefore, is only available to the CPU.
Since our input image and convolution filter are not yet present in the
device memory, we need to copy both data to the GPU before executing any
code on it. In practice, we use CuPy to copy the arrays
<code>diracs</code> and <code>gauss</code> from the host’s Random Access
Memory (RAM) to the GPU memory as follows:</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="im">import</span> cupy <span class="im">as</span> cp</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>diracs_gpu <span class="op">=</span> cp.asarray(diracs)</span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>gauss_gpu <span class="op">=</span> cp.asarray(gauss)</span></code></pre>
</div>
<p>Now it is time to compute the convolution on our GPU. Inconveniently,
SciPy does not offer methods running on GPUs. Hence, we import the
convolution function from a CuPy package aliased as <code>cupyx</code>,
whose sub-package <a href="https://docs.cupy.dev/en/stable/reference/scipy.html" class="external-link"><code>cupyx.scipy</code></a>
performs a selection of the SciPy operations. We will soon verify that
the GPU convolution function of <code>cupyx</code> works out the same
calculations as the CPU convolution function of SciPy. In general, CuPy
proper and NumPy are so similar as are the <code>cupyx</code> methods
and SciPy; this is intended to invite programmers already familiar with
NumPy and SciPy to use the GPU for computing. For now, let’s again
record the execution time on the device for the same convolution as the
host, and can compare the respective performances.</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="im">from</span> cupyx.scipy.signal <span class="im">import</span> convolve2d <span class="im">as</span> convolve2d_gpu</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>convolved_image_gpu <span class="op">=</span> convolve2d_gpu(diracs_gpu, gauss_gpu)</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a><span class="op">%</span>timeit <span class="op">-</span>n <span class="dv">7</span> <span class="op">-</span>r <span class="dv">1</span> convolved_image_gpu <span class="op">=</span> convolve2d_gpu(diracs_gpu, gauss_gpu)</span></code></pre>
</div>
<p>Also the execution time of the GPU convolution will depend very much
on the hardware used, as seen for the host. The timing using a NVIDIA
Tesla T4 on Google Colab was:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>98.2 µs ± 0 ns per loop (mean ± std. dev. of 1 run, 7 loops each)</code></pre>
</div>
<p>This is way faster than the host: more than a 24000-fold performance
improvement, or speedup. Impressive, but is that true?</p>
</div>
<div class="section level2">
<h2 id="measuring-performance">Measuring performance<a class="anchor" aria-label="anchor" href="#measuring-performance"></a></h2>
<p>So far we used <code>timeit</code> to measure the performance of our
Python code, no matter whether it was running on the CPU or was
GPU-accelerated. However, the execution on the GPU is
<em>asynchronous</em>: the Python interpreter takes back control of the
program execution immediately, while the GPU is still executing the
task. Therefore, the timing of <code>timeit</code> is not reliable.</p>
<p>Conveniently, <code>cupyx</code> provides the function
<code>benchmark()</code> that measures the actual execution time in the
GPU. The following code executes <code>convolve2d_gpu()</code> with the
appropriate arguments ten times, and stores inside the
<code>.gpu_times</code> attribute of the variable
<code>execution_gpu</code> the execution time of each run in
seconds.</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="im">from</span> cupyx.profiler <span class="im">import</span> benchmark</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>benchmark_gpu <span class="op">=</span> benchmark(convolve2d_gpu, (diracs_gpu, gauss_gpu), n_repeat<span class="op">=</span><span class="dv">10</span>)</span></code></pre>
</div>
<p>These measurements are also more stable and representative, because
<code>benchmark()</code> disregards the compile time and the repetitions
warm up the GPU. We can then average the execution times, as
follows:</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>gpu_execution_avg <span class="op">=</span> np.average(benchmark_gpu.gpu_times)</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>gpu_execution_avg<span class="sc">:.6f}</span><span class="ss"> s"</span>)</span></code></pre>
</div>
<p>whereby the performance revisited is:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>0.020642 s</code></pre>
</div>
<p>We now have a more reasonable, but still impressive, 116-fold speedup
with respect to the execution on the host.</p>
<div id="challenge-convolution-on-the-gpu-without-cupy" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-convolution-on-the-gpu-without-cupy" class="callout-inner">
<h3 class="callout-title">Challenge: convolution on the GPU without CuPy</h3>
<div class="callout-content">
<p>Try to convolve the NumPy array <code>diracs</code> with the NumPy
array <code>gauss</code> directly on the GPU, that is, without CuPy
arrays. If this works, it will save us the time and effort of
transferring the arrays <code>diracs</code> and <code>gauss</code> to
the GPU.</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<p>We can call the GPU convolution function
<code>convolve2d_gpu()</code> directly with <code>deltas</code> and
<code>gauss</code> as argument:</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>convolve2d_gpu(diracs, gauss)</span></code></pre>
</div>
<p>However, this throws a long error message ending with:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>TypeError: Unsupported type &lt;class 'numpy.ndarray'&gt;</code></pre>
</div>
<p>Unfortunately, it is impossible to access directly from the GPU the
NumPy arrays that live in the host RAM.</p>
</div>
</div>
</div>
</div>
</div>
<div class="section level2">
<h2 id="validation">Validation<a class="anchor" aria-label="anchor" href="#validation"></a></h2>
<p>To check that the host and the device actually produced the same
output, we compare the two output arrays
<code>convolved_image_gpu</code> and <code>convolved_image_cpu</code> as
follows:</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>np.allclose(convolved_image_gpu, convolved_image_cpu)</span></code></pre>
</div>
<p>As you may have expected, the outcome of the comparison confirms that
the results on the host and on the device are the same:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="fu">array</span><span class="op">(</span><span class="va">True</span><span class="op">)</span></span></code></pre>
</div>
<div id="challenge-fairer-comparison-of-cpu-vs.-gpu" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-fairer-comparison-of-cpu-vs.-gpu" class="callout-inner">
<h3 class="callout-title">Challenge: fairer comparison of CPU vs. GPU</h3>
<div class="callout-content">
<p>Compute again the speedup achieved using the GPU, taking into account
also the time spent transferring the data from the CPU to the GPU and
back.</p>
<p>Hint: use the <code>cp.asnumpy()</code> method to copy a CuPy array
back to the host.</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" aria-labelledby="headingSolution2" data-bs-parent="#accordionSolution2">
<div class="accordion-body">
<p>A convenient strategy is to time the execution of a single Python
function that groups the transfers to and from the GPU and the
convolution, as follows:</p>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="kw">def</span> push_compute_pull():</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>    diracs_gpu <span class="op">=</span> cp.asarray(diracs)</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>    gauss_gpu <span class="op">=</span> cp.asarray(gauss)</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>    convolved_image_gpu <span class="op">=</span> convolve2d_gpu(diracs_gpu, gauss_gpu)</span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a>    convolved_image_gpu_in_host <span class="op">=</span> cp.asnumpy(convolved_image_gpu)</span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a>   </span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a>benchmark_gpu <span class="op">=</span> benchmark(push_compute_pull, (), n_repeat<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a>gpu_execution_avg <span class="op">=</span> np.average(benchmark_gpu.gpu_times)</span>
<span id="cb16-9"><a href="#cb16-9" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>gpu_execution_avg<span class="sc">:.6f}</span><span class="ss"> s"</span>)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>0.035400 s</code></pre>
</div>
<p>The speedup taking into account the data transfer decreased from 116
to 67. Nonetheless, accounting for the necessary data transfers is a
better and fairer way to compute performance speedups. As an aside, here
<code>timeit</code> would still provide correct measurements, because
the data transfers force the device and host to <em>sync</em> one with
another.</p>
</div>
</div>
</div>
</div>
</div>
<div class="section level2">
<h2 id="a-shortcut-performing-numpy-routines-on-the-gpu">A shortcut: performing NumPy routines on the GPU<a class="anchor" aria-label="anchor" href="#a-shortcut-performing-numpy-routines-on-the-gpu"></a></h2>
<p>We saw in a previous challenge that we cannot launch the routines of
<code>cupyx</code> directly on NumPy arrays. In fact, we first needed to
transfer the data from the host to the device memory. Conversely, we
also encounter an error when we launch a regular SciPy routine, designed
to run on CPUs, on a CuPy array. Try out the following:</p>
<div class="codewrapper sourceCode" id="cb18">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>convolve2d_cpu(diracs_gpu, gauss_gpu)</span></code></pre>
</div>
<p>which results in</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>...
...
...
TypeError: Implicit conversion to a NumPy array is not allowed.
Please use `.get()` to construct a NumPy array explicitly.</code></pre>
</div>
<p>So, SciPy routines do not accept CuPy arrays as input. However,
instead of performing a 2D convolution, we can execute a simpler 1D
(linear) convolution that uses the NumPy routine
<code>np.convolve()</code> instead of a SciPy routine. To generate the
input appropriate to a linear convolution, we flatten our input image
from 2D to 1D using the method <code>.ravel()</code>. To generate a 1D
filter, we take the diagonal elements of our 2D Gaussian filter. Let’s
launch a linear convolution on the CPU with the following three
instructions:</p>
<div class="codewrapper sourceCode" id="cb20">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a>diracs_1d_cpu <span class="op">=</span> diracs.ravel()</span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a>gauss_1d_cpu <span class="op">=</span> gauss.diagonal()</span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a><span class="op">%</span>timeit <span class="op">-</span>n <span class="dv">1</span> <span class="op">-</span>r <span class="dv">1</span> np.convolve(diracs_1d_cpu, gauss_1d_cpu)</span></code></pre>
</div>
<p>A realistic execution time is:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>270 ms ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)</code></pre>
</div>
<p>After having performed this regular linear convolution on the host
with NumPy, let’s try something bold. We transfer the 1D arrays to the
device and do the convolution with the same NumPy routine, as
follows:</p>
<div class="codewrapper sourceCode" id="cb22">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a>diracs_1d_gpu <span class="op">=</span> cp.asarray(diracs_1d_cpu)</span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a>gauss_1d_gpu <span class="op">=</span> cp.asarray(gauss_1d_cpu)</span>
<span id="cb22-3"><a href="#cb22-3" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" tabindex="-1"></a>benchmark_gpu <span class="op">=</span> benchmark(np.convolve, (diracs_1d_gpu, gauss_1d_gpu), n_repeat<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb22-5"><a href="#cb22-5" tabindex="-1"></a>gpu_execution_avg <span class="op">=</span> np.average(benchmark_gpu.gpu_times)</span>
<span id="cb22-6"><a href="#cb22-6" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>gpu_execution_avg<span class="sc">:.6f}</span><span class="ss"> s"</span>)</span></code></pre>
</div>
<p>You may be surprised that these commands do not throw any error.
Contrary to SciPy, NumPy routines accept CuPy arrays as input, even
though the latter exist only in GPU memory. Indeed, can you recall when
we validated our codes using a NumPy and a CuPy array as input of
<code>np.allclose()</code>? That worked for the same reason. <a href="https://docs.cupy.dev/en/stable/user_guide/interoperability.html#numpy" class="external-link">The
CuPy documentation</a> explains why NumPy routines can handle CuPy
arrays.</p>
<p>The last linear convolution has actually been performed on the GPU,
and faster than the CPU:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>0.014529 s</code></pre>
</div>
<p>With this Numpy shortcut and without much coding effort, we obtained
a good 18-fold speedup.</p>
</div>
</div>
<div class="section level1">
<h1 id="a-scientific-application-image-processing-for-radio-astronomy">A scientific application: image processing for radio astronomy<a class="anchor" aria-label="anchor" href="#a-scientific-application-image-processing-for-radio-astronomy"></a></h1>
<p>In this section, we will perform four classical steps in image
processing for radio astronomy: determination of the background
characteristics, segmentation, connected component labeling, and source
measurements.</p>
<div class="section level2">
<h2 id="import-the-fits-file">Import the FITS file<a class="anchor" aria-label="anchor" href="#import-the-fits-file"></a></h2>
<p>We import a 2048²-pixel image of the electromagnetic radiation at 150
MHz around the Galactic Center, as observed by the Indian Giant
Metrewave Radio Telescope (GMRT).</p>
<p>The image is stored <a href=".././data/GMRT_image_of_Galactic_Center.fits">in this lesson’s
repository</a> as a <a href="https://en.wikipedia.org/wiki/FITS" class="external-link">FITS</a> file. The
<code>astropy</code> Python package enables us to read in this file and,
for compatibility with Python, convert the <a href="https://en.wikipedia.org/wiki/Endianness" class="external-link">byte ordering</a> from
the big to little endian, as follows:</p>
<div class="codewrapper sourceCode" id="cb24">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a><span class="im">from</span> astropy.io <span class="im">import</span> fits</span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" tabindex="-1"></a><span class="cf">with</span> fits.<span class="bu">open</span>(<span class="st">"GMRT_image_of_Galactic_Center.fits"</span>) <span class="im">as</span> hdul:</span>
<span id="cb24-4"><a href="#cb24-4" tabindex="-1"></a>    data <span class="op">=</span> hdul[<span class="dv">0</span>].data.byteswap().newbyteorder()</span></code></pre>
</div>
</div>
<div class="section level2">
<h2 id="inspect-the-image">Inspect the image<a class="anchor" aria-label="anchor" href="#inspect-the-image"></a></h2>
<p>Let’s have a look at this image. Left and right in the data will be
swapped with the method <code>np.fliplr()</code> just to adhere to the
astronomical convention of the <a href="https://en.wikipedia.org/wiki/Right_ascension" class="external-link">right ascension</a>
increasing leftwards.</p>
<div class="codewrapper sourceCode" id="cb25">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a><span class="im">from</span> matplotlib.colors <span class="im">import</span> LogNorm</span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a>maxim <span class="op">=</span> data.<span class="bu">max</span>()</span>
<span id="cb25-4"><a href="#cb25-4" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" tabindex="-1"></a>fig <span class="op">=</span> pyl.figure(figsize<span class="op">=</span>(<span class="dv">50</span>, <span class="fl">12.5</span>))</span>
<span id="cb25-6"><a href="#cb25-6" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb25-7"><a href="#cb25-7" tabindex="-1"></a>im_plot <span class="op">=</span> ax.imshow(np.fliplr(data), cmap<span class="op">=</span>pyl.cm.gray_r, norm<span class="op">=</span>LogNorm(vmin <span class="op">=</span> maxim<span class="op">/</span><span class="dv">10</span>, vmax<span class="op">=</span>maxim<span class="op">/</span><span class="dv">100</span>))</span>
<span id="cb25-8"><a href="#cb25-8" tabindex="-1"></a>pyl.colorbar(im_plot, ax<span class="op">=</span>ax)</span></code></pre>
</div>
<figure><img src=".././fig/improved_image_of_GC.png" alt="Image of the Galactic Center" class="figure mx-auto d-block"><div class="figcaption">Image of the Galactic Center at the radio
frequency of 150 MHz</div>
</figure><p>Stars, remnants of supernovas (massive exploded stars), and distant
galaxies are possible radiation sources observed in this image. We can
spot a few dozen radiation sources in fairly good quality in the lower
left and upper right. In contrast, the quality is worse in the diagonal
from the upper left to the lower right, because the radio telescope has
a limited sensitivity and cannot look into large radiation sources.
Nonetheless, you can notice the Galactic Center in the middle of the
image and supernova shells as ring-like formations elsewhere.</p>
<p>The telescope accuracy has added background noise to the image. Yet,
we want to identify all the radiation sources in this image, determine
their positions, and measure their radiation fluxes. How can we then
assert whether a high-intensity pixel is a peak of the noise or a
genuine source? Assuming that the background noise is normally
distributed with standard deviation <span class="math inline">\(\sigma\)</span>, the chance of its intensity being
larger than 5<span class="math inline">\(\sigma\)</span> is 2.9e-7. The
chance of picking from our image of 2048² (4.2e6) pixels at least one
that is so extremely bright because of noise is thus less than 50%.</p>
<p>Before moving on, let’s determine some summary statistics of the
radiation intensity in the input image:</p>
<div class="codewrapper sourceCode" id="cb26">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a>mean_ <span class="op">=</span> data.mean()</span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a>median_ <span class="op">=</span> np.median(data)</span>
<span id="cb26-3"><a href="#cb26-3" tabindex="-1"></a>stddev_ <span class="op">=</span> np.std(data)</span>
<span id="cb26-4"><a href="#cb26-4" tabindex="-1"></a>max_ <span class="op">=</span> np.amax(data)</span>
<span id="cb26-5"><a href="#cb26-5" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"mean = </span><span class="sc">{</span>mean_<span class="sc">:.3e}</span><span class="ss">, median = </span><span class="sc">{</span>median_<span class="sc">:.3e}</span><span class="ss">, sttdev = </span><span class="sc">{</span>stddev_<span class="sc">:.3e}</span><span class="ss">, maximum = </span><span class="sc">{</span>max_<span class="sc">:.3e}</span><span class="ss">"</span>)</span></code></pre>
</div>
<p>This gives (in Jy/beam):</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>mean = 3.898e-04, median = 1.571e-05, sttdev = 1.993e-02, maximum = 2.506e+00</code></pre>
</div>
<p>The maximum flux density is 2506 mJy/beam coming from the Galactic
Center, the overall standard deviation 19.9 mJy/beam, and the median
1.57e-05 mJy/beam.</p>
</div>
<div class="section level2">
<h2 id="step-1-determining-the-characteristics-of-the-background">Step 1: Determining the characteristics of the background<a class="anchor" aria-label="anchor" href="#step-1-determining-the-characteristics-of-the-background"></a></h2>
<p>First, we separate the background pixels from the source pixels using
an iterative procedure called <span class="math inline">\(\kappa\)</span>-<span class="math inline">\(\sigma\)</span> clipping, which assumes that high
intensity is more likely to result from genuine sources. We start from
the standard deviation (<span class="math inline">\(\sigma\)</span>) and
the median (<span class="math inline">\(\mu_{1/2}\)</span>) of all pixel
intensities, as computed above. We then discard (clip) the pixels whose
intensity is larger than <span class="math inline">\(\mu_{1/2} +
3\sigma\)</span> or smaller than <span class="math inline">\(\mu_{1/2} -
3\sigma\)</span>. In the next pass, we compute again the median and
standard deviation of the clipped set, and clip once more. We repeat
these operations until no more pixels are clipped, that is, there are no
outliers in the designated tails.</p>
<p>In the meantime, you may have noticed already that <span class="math inline">\(\kappa\)</span>-<span class="math inline">\(\sigma\)</span> clipping is a compute intensive
task that could be implemented in a GPU. For the moment, let’s implement
the algorithm with the NumPy code for a CPU, as follows:</p>
<div class="codewrapper sourceCode" id="cb28">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a><span class="co"># Flattening our 2D data makes subsequent steps easier</span></span>
<span id="cb28-2"><a href="#cb28-2" tabindex="-1"></a>data_flat <span class="op">=</span> data.ravel()</span>
<span id="cb28-3"><a href="#cb28-3" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" tabindex="-1"></a><span class="co"># Here is a kappa-sigma clipper for the CPU</span></span>
<span id="cb28-5"><a href="#cb28-5" tabindex="-1"></a><span class="kw">def</span> ks_clipper_cpu(data_flat):</span>
<span id="cb28-6"><a href="#cb28-6" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb28-7"><a href="#cb28-7" tabindex="-1"></a>         med <span class="op">=</span> np.median(data_flat)</span>
<span id="cb28-8"><a href="#cb28-8" tabindex="-1"></a>         std <span class="op">=</span> np.std(data_flat)</span>
<span id="cb28-9"><a href="#cb28-9" tabindex="-1"></a>         clipped_below <span class="op">=</span> data_flat.compress(data_flat <span class="op">&gt;</span> med <span class="op">-</span> <span class="dv">3</span> <span class="op">*</span> std)</span>
<span id="cb28-10"><a href="#cb28-10" tabindex="-1"></a>         clipped_data <span class="op">=</span> clipped_below.compress(clipped_below <span class="op">&lt;</span> med <span class="op">+</span> <span class="dv">3</span> <span class="op">*</span> std)</span>
<span id="cb28-11"><a href="#cb28-11" tabindex="-1"></a>         <span class="cf">if</span> <span class="bu">len</span>(clipped_data) <span class="op">==</span> <span class="bu">len</span>(data_flat):</span>
<span id="cb28-12"><a href="#cb28-12" tabindex="-1"></a>             <span class="cf">break</span></span>
<span id="cb28-13"><a href="#cb28-13" tabindex="-1"></a>         data_flat <span class="op">=</span> clipped_data  </span>
<span id="cb28-14"><a href="#cb28-14" tabindex="-1"></a>    <span class="cf">return</span> data_flat</span>
<span id="cb28-15"><a href="#cb28-15" tabindex="-1"></a></span>
<span id="cb28-16"><a href="#cb28-16" tabindex="-1"></a>data_clipped_cpu <span class="op">=</span> ks_clipper_cpu(data_flat)</span>
<span id="cb28-17"><a href="#cb28-17" tabindex="-1"></a>timing_ks_clipping_cpu <span class="op">=</span> <span class="op">%</span>timeit <span class="op">-</span>o ks_clipper_cpu(data_flat)</span>
<span id="cb28-18"><a href="#cb28-18" tabindex="-1"></a>fastest_ks_clipping_cpu <span class="op">=</span> timing_ks_clipping_cpu.best</span>
<span id="cb28-19"><a href="#cb28-19" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Fastest ks clipping time on CPU = </span><span class="sc">{</span><span class="dv">1000</span> <span class="op">*</span> fastest_ks_clipping_cpu<span class="sc">:.3e}</span><span class="ss"> ms."</span>)</span></code></pre>
</div>
<p>The performance is close to 1 s and, hopefully, can be sped up on the
GPU.</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>793 ms ± 17.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
Fastest ks clipping time on CPU = 7.777e+02 ms.</code></pre>
</div>
<p>Finally, let’s see how the <span class="math inline">\(\kappa\)</span>-<span class="math inline">\(\sigma\)</span> clipping has influenced the
summary statistics:</p>
<div class="codewrapper sourceCode" id="cb30">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a>clipped_mean_ <span class="op">=</span> data_clipped.mean()</span>
<span id="cb30-2"><a href="#cb30-2" tabindex="-1"></a>clipped_median_ <span class="op">=</span> np.median(data_clipped_cpu)</span>
<span id="cb30-3"><a href="#cb30-3" tabindex="-1"></a>clipped_stddev_ <span class="op">=</span> np.std(data_clipped_cpu)</span>
<span id="cb30-4"><a href="#cb30-4" tabindex="-1"></a>clipped_max_ <span class="op">=</span> np.amax(data_clipped_cpu)</span>
<span id="cb30-5"><a href="#cb30-5" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"mean of clipped = </span><span class="sc">{</span>clipped_mean_<span class="sc">:.3e}</span><span class="ss">,</span></span>
<span id="cb30-6"><a href="#cb30-6" tabindex="-1"></a><span class="er">      median of clipped = {clipped_median_:.3e} \n</span></span>
<span id="cb30-7"><a href="#cb30-7" tabindex="-1"></a>      standard deviation of clipped <span class="op">=</span> {clipped_stddev_:<span class="fl">.3</span><span class="er">e</span>},</span>
<span id="cb30-8"><a href="#cb30-8" tabindex="-1"></a>      maximum of clipped <span class="op">=</span> {clipped_max_:<span class="fl">.3</span><span class="er">e</span>}<span class="st">")</span></span></code></pre>
</div>
<p>The first-order statistics have become smaller, which reassures us
that <code>data_clipped</code> contains background pixels:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>mean of clipped = -1.945e-06, median of clipped = -9.796e-06
standard deviation of clipped = 1.334e-02, maximum of clipped = 4.000e-02</code></pre>
</div>
<p>The standard deviation of the intensity in the background pixels is
be the basis for the next step.</p>
<div id="challenge-kappa-sigma-clipping-on-the-gpu" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-kappa-sigma-clipping-on-the-gpu" class="callout-inner">
<h3 class="callout-title">Challenge: <span class="math inline">\(\kappa\)</span>-<span class="math inline">\(\sigma\)</span> clipping on the GPU</h3>
<div class="callout-content">
<p>Now that you know how the <span class="math inline">\(\kappa\)</span>-<span class="math inline">\(\sigma\)</span> clipping algorithm works, perform
it on the GPU using CuPy. Compute the speedup, including the data
transfer to and from the GPU.</p>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3"> Show me the solution </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" aria-labelledby="headingSolution3" data-bs-parent="#accordionSolution3">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb32">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a><span class="kw">def</span> ks_clipper_gpu(data_flat):</span>
<span id="cb32-2"><a href="#cb32-2" tabindex="-1"></a>    data_flat_gpu <span class="op">=</span> cp.asarray(data_flat)</span>
<span id="cb32-3"><a href="#cb32-3" tabindex="-1"></a>    data_gpu_clipped <span class="op">=</span> ks_clipper_cpu(data_flat_gpu)</span>
<span id="cb32-4"><a href="#cb32-4" tabindex="-1"></a>    <span class="cf">return</span> cp.asnumpy(data_gpu_clipped)</span>
<span id="cb32-5"><a href="#cb32-5" tabindex="-1"></a></span>
<span id="cb32-6"><a href="#cb32-6" tabindex="-1"></a>data_clipped_gpu <span class="op">=</span> ks_clipper_gpu(data_flat)</span>
<span id="cb32-7"><a href="#cb32-7" tabindex="-1"></a>timing_ks_clipping_gpu <span class="op">=</span> benchmark(ks_clipper_gpu,</span>
<span id="cb32-8"><a href="#cb32-8" tabindex="-1"></a>                                   (data_flat, ),</span>
<span id="cb32-9"><a href="#cb32-9" tabindex="-1"></a>                                   n_repeat<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb32-10"><a href="#cb32-10" tabindex="-1"></a>fastest_ks_clipping_gpu <span class="op">=</span> np.amin(timing_ks_clipping_gpu.gpu_times)</span>
<span id="cb32-11"><a href="#cb32-11" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span><span class="dv">1000</span> <span class="op">*</span> fastest_ks_clipping_gpu<span class="sc">:.3e}</span><span class="ss"> ms"</span>)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>6.329e+01 ms</code></pre>
</div>
<div class="codewrapper sourceCode" id="cb34">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a>speedup_factor <span class="op">=</span> fastest_ks_clipping_cpu<span class="op">/</span>fastest_ks_clipping_gpu</span>
<span id="cb34-2"><a href="#cb34-2" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The speedup factor for ks clipping is: </span><span class="sc">{</span>speedup_factor<span class="sc">:.3e}</span><span class="ss">"</span>)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>The speedup factor for ks clipping is: 1.232e+01</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="section level2">
<h2 id="step-2-segmenting-the-image">Step 2: Segmenting the image<a class="anchor" aria-label="anchor" href="#step-2-segmenting-the-image"></a></h2>
<p>We have already estimated that clipping an image of 2048² pixels at
the <span class="math inline">\(5 \sigma\)</span> level yields a chance
of less than 50% that at least one out of all the sources we detect is a
noise peak. So let’s set the threshold at <span class="math inline">\(5\sigma\)</span> and segment it.</p>
<p>First let’s check that the standard deviation from our clipper on the
GPU is the same:</p>
<div class="codewrapper sourceCode" id="cb36">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a>stddev_gpu_ <span class="op">=</span> np.std(data_clipped_gpu)</span>
<span id="cb36-2"><a href="#cb36-2" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"standard deviation of background_noise = </span><span class="sc">{</span>stddev_gpu_<span class="sc">:.4f}</span><span class="ss"> Jy/beam"</span>)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>standard deviation of background_noise = 0.0133 Jy/beam</code></pre>
</div>
<p>We then apply the <span class="math inline">\(5 \sigma\)</span>
threshold to the image with this standard deviation:</p>
<div class="codewrapper sourceCode" id="cb38">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a>threshold <span class="op">=</span> <span class="dv">5</span> <span class="op">*</span> stddev_gpu_</span>
<span id="cb38-2"><a href="#cb38-2" tabindex="-1"></a>segmented_image <span class="op">=</span> np.where(data <span class="op">&gt;</span> threshold, <span class="dv">1</span>,  <span class="dv">0</span>)</span>
<span id="cb38-3"><a href="#cb38-3" tabindex="-1"></a>timing_segmentation_CPU <span class="op">=</span> <span class="op">%</span>timeit <span class="op">-</span>o np.where(data <span class="op">&gt;</span> threshold, <span class="dv">1</span>,  <span class="dv">0</span>)</span>
<span id="cb38-4"><a href="#cb38-4" tabindex="-1"></a>fastest_segmentation_CPU <span class="op">=</span> timing_segmentation_CPU.best </span>
<span id="cb38-5"><a href="#cb38-5" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Fastest CPU segmentation time = </span><span class="sc">{</span><span class="dv">1000</span> <span class="op">*</span> fastest_segmentation_CPU<span class="sc">:.3e}</span><span class="ss"> ms."</span>)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>6.41 ms ± 55.3 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
Fastest CPU segmentation time = 6.294e+00 ms.</code></pre>
</div>
</div>
<div class="section level2">
<h2 id="step-3-labeling-the-segmented-data">Step 3: Labeling the segmented data<a class="anchor" aria-label="anchor" href="#step-3-labeling-the-segmented-data"></a></h2>
<p>This is called connected component labeling (CCL). It will replace
pixel values in the segmented image - just consisting of zeros and ones
- of the first connected group of pixels with the value 1 - so nothing
changed, but just for that first group - the pixel values in the second
group of connected pixels will all be 2, the third connected group of
pixels will all have the value 3 etc.</p>
<p>This is a CPU code for connected component labeling.</p>
<div class="codewrapper sourceCode" id="cb40">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" tabindex="-1"></a><span class="im">from</span> scipy.ndimage <span class="im">import</span> label <span class="im">as</span> label_cpu</span>
<span id="cb40-2"><a href="#cb40-2" tabindex="-1"></a>labeled_image <span class="op">=</span> np.empty(data.shape)</span>
<span id="cb40-3"><a href="#cb40-3" tabindex="-1"></a>number_of_sources_in_image <span class="op">=</span> label_cpu(segmented_image, output <span class="op">=</span> labeled_image)</span>
<span id="cb40-4"><a href="#cb40-4" tabindex="-1"></a>sigma_unicode <span class="op">=</span> <span class="st">"</span><span class="ch">\u03C3</span><span class="st">"</span></span>
<span id="cb40-5"><a href="#cb40-5" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The number of sources in the image at the 5</span><span class="sc">{</span>sigma_unicode<span class="sc">}</span><span class="ss"> level is </span><span class="sc">{</span>number_of_sources_in_image<span class="sc">}</span><span class="ss">."</span>)</span>
<span id="cb40-6"><a href="#cb40-6" tabindex="-1"></a></span>
<span id="cb40-7"><a href="#cb40-7" tabindex="-1"></a>timing_CCL_CPU <span class="op">=</span> <span class="op">%</span>timeit <span class="op">-</span>o label_cpu(segmented_image, output <span class="op">=</span> labeled_image)</span>
<span id="cb40-8"><a href="#cb40-8" tabindex="-1"></a>fastest_CCL_CPU <span class="op">=</span> timing_CCL_CPU.best</span>
<span id="cb40-9"><a href="#cb40-9" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Fastest CPU CCL time = </span><span class="sc">{</span><span class="dv">1000</span> <span class="op">*</span> fastest_CCL_CPU<span class="sc">:.3e}</span><span class="ss"> ms."</span>)</span></code></pre>
</div>
<p>This gives, on my machine:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>The number of sources in the image at the 5σ level is 185.
26.3 ms ± 965 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
Fastest CPU CCL time = 2.546e+01 ms.</code></pre>
</div>
<p>Let’s not just accept the answer, but also do a sanity check. What
are the values in the labeled image?</p>
<div class="codewrapper sourceCode" id="cb42">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"These are all the pixel values we can find in the labeled image: </span><span class="sc">{</span>np<span class="sc">.</span>unique(labeled_image)<span class="sc">}</span><span class="ss">"</span>)</span></code></pre>
</div>
<p>This should show the following output:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>These are all the pixel values we can find in the labeled image:
[  0.   1.   2.   3.   4.   5.   6.   7.   8.   9.  10.  11.  12.  13.
  14.  15.  16.  17.  18.  19.  20.  21.  22.  23.  24.  25.  26.  27.
  28.  29.  30.  31.  32.  33.  34.  35.  36.  37.  38.  39.  40.  41.
  42.  43.  44.  45.  46.  47.  48.  49.  50.  51.  52.  53.  54.  55.
  56.  57.  58.  59.  60.  61.  62.  63.  64.  65.  66.  67.  68.  69.
  70.  71.  72.  73.  74.  75.  76.  77.  78.  79.  80.  81.  82.  83.
  84.  85.  86.  87.  88.  89.  90.  91.  92.  93.  94.  95.  96.  97.
  98.  99. 100. 101. 102. 103. 104. 105. 106. 107. 108. 109. 110. 111.
 112. 113. 114. 115. 116. 117. 118. 119. 120. 121. 122. 123. 124. 125.
 126. 127. 128. 129. 130. 131. 132. 133. 134. 135. 136. 137. 138. 139.
 140. 141. 142. 143. 144. 145. 146. 147. 148. 149. 150. 151. 152. 153.
 154. 155. 156. 157. 158. 159. 160. 161. 162. 163. 164. 165. 166. 167.
 168. 169. 170. 171. 172. 173. 174. 175. 176. 177. 178. 179. 180. 181.
 182. 183. 184. 185.]</code></pre>
</div>
</div>
<div class="section level2">
<h2 id="step-4-measuring-the-radiation-sources">Step 4: Measuring the radiation sources<a class="anchor" aria-label="anchor" href="#step-4-measuring-the-radiation-sources"></a></h2>
<p>We are ready for the final step. We have been given observing time to
make this beautiful image of the Galactic Center, we have determined its
background statistics, we have separated actual cosmic sources from
noise and now we want to measure these cosmic sources. What are their
positions and what are their flux densities?</p>
<p>Again, the algorithms from <code>scipy.ndimage</code> help us to
determine these quantities. This is the CPU code for measuring our
sources.</p>
<div class="codewrapper sourceCode" id="cb44">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" tabindex="-1"></a><span class="im">from</span> scipy.ndimage <span class="im">import</span> center_of_mass <span class="im">as</span> com_cpu</span>
<span id="cb44-2"><a href="#cb44-2" tabindex="-1"></a><span class="im">from</span> scipy.ndimage <span class="im">import</span> sum_labels <span class="im">as</span> sl_cpu</span>
<span id="cb44-3"><a href="#cb44-3" tabindex="-1"></a>all_positions <span class="op">=</span> com_cpu(data, labeled_image,</span>
<span id="cb44-4"><a href="#cb44-4" tabindex="-1"></a>                        <span class="bu">range</span>(<span class="dv">1</span>, number_of_sources_in_image<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb44-5"><a href="#cb44-5" tabindex="-1"></a>all_integrated_fluxes <span class="op">=</span> sl_cpu(data, labeled_image,</span>
<span id="cb44-6"><a href="#cb44-6" tabindex="-1"></a>                               <span class="bu">range</span>(<span class="dv">1</span>, number_of_sources_in_image<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb44-7"><a href="#cb44-7" tabindex="-1"></a></span>
<span id="cb44-8"><a href="#cb44-8" tabindex="-1"></a><span class="bu">print</span> (<span class="ss">f'These are the ten highest integrated fluxes of the sources in my </span><span class="ch">\n</span><span class="ss"> image: </span><span class="sc">{</span>np<span class="sc">.</span>sort(all_integrated_fluxes)[<span class="op">-</span><span class="dv">10</span>:]<span class="sc">}</span><span class="ss">'</span>)</span></code></pre>
</div>
<p>which gives the Galactic Center as the most luminous source, which
makes sense when we look at our image.</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>These are the ten highest integrated fluxes of the sources in my image:
[ 38.90615184  41.91485894  43.02203498  47.30590784  51.23707351
  58.07289425  68.85673917  70.31223921  95.16443585 363.58937774]</code></pre>
</div>
<p>Now we can try to measure the execution times for both algorithms,
like this:</p>
<div class="codewrapper sourceCode" id="cb46">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" tabindex="-1"></a><span class="op">%%</span>timeit <span class="op">-</span>o</span>
<span id="cb46-2"><a href="#cb46-2" tabindex="-1"></a>all_positions <span class="op">=</span> com_cpu(data, labeled_image,</span>
<span id="cb46-3"><a href="#cb46-3" tabindex="-1"></a>                        <span class="bu">range</span>(<span class="dv">1</span>, number_of_sources_in_image<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb46-4"><a href="#cb46-4" tabindex="-1"></a>all_integrated_fluxes <span class="op">=</span> sl_cpu(data, labeled_image,</span>
<span id="cb46-5"><a href="#cb46-5" tabindex="-1"></a>                               <span class="bu">range</span>(<span class="dv">1</span>, number_of_sources_in_image<span class="op">+</span><span class="dv">1</span>))</span></code></pre>
</div>
<p>Which yields, on my machine:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>797 ms ± 9.32 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&lt;TimeitResult : 797 ms ± 9.32 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)&gt;</code></pre>
</div>
<p>To collect the result from that timing in our next cell block, we
need a trick that uses the <code>_</code> variable.</p>
<div class="codewrapper sourceCode" id="cb48">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" tabindex="-1"></a>timing_source_measurements_CPU <span class="op">=</span> _</span>
<span id="cb48-2"><a href="#cb48-2" tabindex="-1"></a>fastest_source_measurements_CPU <span class="op">=</span> timing_source_measurements_CPU.best</span>
<span id="cb48-3"><a href="#cb48-3" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Fastest CPU set of source measurements = </span><span class="sc">{</span><span class="dv">1000</span> <span class="op">*</span> fastest_source_measurements_CPU<span class="sc">:.3e}</span><span class="ss"> ms."</span>)</span></code></pre>
</div>
<p>Which yields</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Fastest CPU set of source measurements = 7.838e+02 ms.</code></pre>
</div>
<div id="challenge-putting-it-all-together" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-putting-it-all-together" class="callout-inner">
<h3 class="callout-title">Challenge: putting it all together</h3>
<div class="callout-content">
<p>Combine the first two steps of image processing for astronomy,
i.e. determining background characteristics e.g. through <span class="math inline">\(\kappa\)</span>-<span class="math inline">\(\sigma\)</span> clipping and segmentation into a
single function, that works for both CPU and GPU. Next, write a function
for connected component labeling and source measurements on the GPU and
calculate the overall speedup factor for the combined four steps of
image processing in astronomy on the GPU relative to the CPU. Finally,
verify your output by comparing with the previous output, using the
CPU.</p>
</div>
</div>
</div>
<div id="accordionSolution4" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution4" aria-expanded="false" aria-controls="collapseSolution4">
  <h4 class="accordion-header" id="headingSolution4"> Show me the solution </h4>
</button>
<div id="collapseSolution4" class="accordion-collapse collapse" aria-labelledby="headingSolution4" data-bs-parent="#accordionSolution4">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb50">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" tabindex="-1"></a><span class="kw">def</span> first_two_steps_for_both_CPU_and_GPU(data):</span>
<span id="cb50-2"><a href="#cb50-2" tabindex="-1"></a>    data_flat <span class="op">=</span> data.ravel()</span>
<span id="cb50-3"><a href="#cb50-3" tabindex="-1"></a>    data_clipped <span class="op">=</span> ks_clipper_cpu(data_flat)</span>
<span id="cb50-4"><a href="#cb50-4" tabindex="-1"></a>    stddev_ <span class="op">=</span> np.std(data_clipped)</span>
<span id="cb50-5"><a href="#cb50-5" tabindex="-1"></a>    threshold <span class="op">=</span> <span class="dv">5</span> <span class="op">*</span> stddev_</span>
<span id="cb50-6"><a href="#cb50-6" tabindex="-1"></a>    segmented_image <span class="op">=</span> np.where(data <span class="op">&gt;</span> threshold, <span class="dv">1</span>,  <span class="dv">0</span>)</span>
<span id="cb50-7"><a href="#cb50-7" tabindex="-1"></a>    <span class="cf">return</span> segmented_image</span>
<span id="cb50-8"><a href="#cb50-8" tabindex="-1"></a></span>
<span id="cb50-9"><a href="#cb50-9" tabindex="-1"></a><span class="kw">def</span> ccl_and_source_measurements_on_CPU(data_CPU, segmented_image_CPU):</span>
<span id="cb50-10"><a href="#cb50-10" tabindex="-1"></a>    labeled_image_CPU <span class="op">=</span> np.empty(data_CPU.shape)</span>
<span id="cb50-11"><a href="#cb50-11" tabindex="-1"></a>    number_of_sources_in_image <span class="op">=</span> label_cpu(segmented_image_CPU, </span>
<span id="cb50-12"><a href="#cb50-12" tabindex="-1"></a>                                           output<span class="op">=</span> labeled_image_CPU)</span>
<span id="cb50-13"><a href="#cb50-13" tabindex="-1"></a>    all_positions <span class="op">=</span> com_cpu(data_CPU, labeled_image_CPU, </span>
<span id="cb50-14"><a href="#cb50-14" tabindex="-1"></a>                            np.arange(<span class="dv">1</span>, number_of_sources_in_image<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb50-15"><a href="#cb50-15" tabindex="-1"></a>    all_fluxes <span class="op">=</span> sl_cpu(data_CPU, labeled_image_CPU, </span>
<span id="cb50-16"><a href="#cb50-16" tabindex="-1"></a>                        np.arange(<span class="dv">1</span>, number_of_sources_in_image<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb50-17"><a href="#cb50-17" tabindex="-1"></a>    <span class="cf">return</span> np.array(all_positions), np.array(all_fluxes)</span>
<span id="cb50-18"><a href="#cb50-18" tabindex="-1"></a></span>
<span id="cb50-19"><a href="#cb50-19" tabindex="-1"></a>CPU_output <span class="op">=</span> ccl_and_source_measurements_on_CPU(data,</span>
<span id="cb50-20"><a href="#cb50-20" tabindex="-1"></a>                                            first_two_steps_for_both_CPU_and_GPU(data))</span>
<span id="cb50-21"><a href="#cb50-21" tabindex="-1"></a></span>
<span id="cb50-22"><a href="#cb50-22" tabindex="-1"></a>timing_complete_processing_CPU <span class="op">=</span>  benchmark(</span>
<span id="cb50-23"><a href="#cb50-23" tabindex="-1"></a>                                            ccl_and_source_measurements_on_CPU,</span>
<span id="cb50-24"><a href="#cb50-24" tabindex="-1"></a>                                            (data,</span>
<span id="cb50-25"><a href="#cb50-25" tabindex="-1"></a>                                            first_two_steps_for_both_CPU_and_GPU(data)),                                             n_repeat<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb50-26"><a href="#cb50-26" tabindex="-1"></a></span>
<span id="cb50-27"><a href="#cb50-27" tabindex="-1"></a>fastest_complete_processing_CPU <span class="op">=</span> np.amin(timing_complete_processing_CPU.cpu_times)</span>
<span id="cb50-28"><a href="#cb50-28" tabindex="-1"></a></span>
<span id="cb50-29"><a href="#cb50-29" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The four steps of image processing for astronomy take </span><span class="sc">{</span><span class="dv">1000</span> <span class="op">*</span> fastest_complete_processing_CPU<span class="sc">:.3e}</span><span class="ss"> ms</span><span class="ch">\n</span><span class="ss"> on our CPU."</span>)</span>
<span id="cb50-30"><a href="#cb50-30" tabindex="-1"></a></span>
<span id="cb50-31"><a href="#cb50-31" tabindex="-1"></a><span class="im">from</span> cupyx.scipy.ndimage <span class="im">import</span> label <span class="im">as</span> label_gpu</span>
<span id="cb50-32"><a href="#cb50-32" tabindex="-1"></a><span class="im">from</span> cupyx.scipy.ndimage <span class="im">import</span> center_of_mass <span class="im">as</span> com_gpu</span>
<span id="cb50-33"><a href="#cb50-33" tabindex="-1"></a><span class="im">from</span> cupyx.scipy.ndimage <span class="im">import</span> sum_labels <span class="im">as</span> sl_gpu</span>
<span id="cb50-34"><a href="#cb50-34" tabindex="-1"></a></span>
<span id="cb50-35"><a href="#cb50-35" tabindex="-1"></a><span class="kw">def</span> ccl_and_source_measurements_on_GPU(data_GPU, segmented_image_GPU):</span>
<span id="cb50-36"><a href="#cb50-36" tabindex="-1"></a>    labeled_image_GPU <span class="op">=</span> cp.empty(data_GPU.shape)</span>
<span id="cb50-37"><a href="#cb50-37" tabindex="-1"></a>    number_of_sources_in_image <span class="op">=</span> label_gpu(segmented_image_GPU, </span>
<span id="cb50-38"><a href="#cb50-38" tabindex="-1"></a>                                           output<span class="op">=</span> labeled_image_GPU)</span>
<span id="cb50-39"><a href="#cb50-39" tabindex="-1"></a>    all_positions <span class="op">=</span> com_gpu(data_GPU, labeled_image_GPU, </span>
<span id="cb50-40"><a href="#cb50-40" tabindex="-1"></a>                            cp.arange(<span class="dv">1</span>, number_of_sources_in_image<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb50-41"><a href="#cb50-41" tabindex="-1"></a>    all_fluxes <span class="op">=</span> sl_gpu(data_GPU, labeled_image_GPU, </span>
<span id="cb50-42"><a href="#cb50-42" tabindex="-1"></a>                        cp.arange(<span class="dv">1</span>, number_of_sources_in_image<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb50-43"><a href="#cb50-43" tabindex="-1"></a>    <span class="co"># This seems redundant, but we want to return ndarrays (Numpy)</span></span>
<span id="cb50-44"><a href="#cb50-44" tabindex="-1"></a>    <span class="co"># and what we have are lists.</span></span>
<span id="cb50-45"><a href="#cb50-45" tabindex="-1"></a>    <span class="co"># These first have to be converted to</span></span>
<span id="cb50-46"><a href="#cb50-46" tabindex="-1"></a>    <span class="co"># Cupy arrays before they can be converted to Numpy arrays.</span></span>
<span id="cb50-47"><a href="#cb50-47" tabindex="-1"></a>    <span class="cf">return</span> cp.asnumpy(cp.asarray(all_positions)),</span>
<span id="cb50-48"><a href="#cb50-48" tabindex="-1"></a>                      cp.asnumpy(cp.asarray(all_fluxes))</span>
<span id="cb50-49"><a href="#cb50-49" tabindex="-1"></a></span>
<span id="cb50-50"><a href="#cb50-50" tabindex="-1"></a>GPU_output <span class="op">=</span> ccl_and_source_measurements_on_GPU(cp.asarray(data), first_two_steps_for_both_CPU_and_GPU(cp.asarray(data)))</span>
<span id="cb50-51"><a href="#cb50-51" tabindex="-1"></a></span>
<span id="cb50-52"><a href="#cb50-52" tabindex="-1"></a>timing_complete_processing_GPU <span class="op">=</span>  benchmark(ccl_and_source_measurements_on_GPU, (cp.asarray(data), first_two_steps_for_both_CPU_and_GPU(cp.asarray(data))), n_repeat<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb50-53"><a href="#cb50-53" tabindex="-1"></a></span>
<span id="cb50-54"><a href="#cb50-54" tabindex="-1"></a>fastest_complete_processing_GPU <span class="op">=</span> np.amin(timing_complete_processing_GPU.gpu_times)</span>
<span id="cb50-55"><a href="#cb50-55" tabindex="-1"></a></span>
<span id="cb50-56"><a href="#cb50-56" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The four steps of image processing for astronomy take </span><span class="sc">{</span><span class="dv">1000</span> <span class="op">*</span> fastest_complete_processing_GPU<span class="sc">:.3e}</span><span class="ss"> ms</span><span class="ch">\n</span><span class="ss"> on our GPU."</span>)</span>
<span id="cb50-57"><a href="#cb50-57" tabindex="-1"></a></span>
<span id="cb50-58"><a href="#cb50-58" tabindex="-1"></a>overall_speedup_factor <span class="op">=</span> fastest_complete_processing_CPU <span class="op">/</span>                         fastest_complete_processing_GPU</span>
<span id="cb50-59"><a href="#cb50-59" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"This means that the overall speedup factor GPU vs CPU equals: </span><span class="sc">{</span>overall_speedup_factor<span class="sc">:.3e}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb50-60"><a href="#cb50-60" tabindex="-1"></a></span>
<span id="cb50-61"><a href="#cb50-61" tabindex="-1"></a>all_positions_agree <span class="op">=</span> np.allclose(CPU_output[<span class="dv">0</span>], GPU_output[<span class="dv">0</span>])</span>
<span id="cb50-62"><a href="#cb50-62" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The CPU and GPU positions agree: </span><span class="sc">{</span>all_positions_agree<span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb50-63"><a href="#cb50-63" tabindex="-1"></a></span>
<span id="cb50-64"><a href="#cb50-64" tabindex="-1"></a>all_fluxes_agree <span class="op">=</span> np.allclose(CPU_output[<span class="dv">1</span>], GPU_output[<span class="dv">1</span>])</span>
<span id="cb50-65"><a href="#cb50-65" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The CPU and GPU fluxes agree: </span><span class="sc">{</span>all_positions_agree<span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>The four steps of image processing for astronomy take 1.060e+03 ms on our CPU.
The four steps of image processing for astronomy take 5.770e+01 ms on our GPU.
This means that the overall speedup factor GPU vs _mCPU equals: 1.838e+01

The CPU and GPU positions agree: True

The CPU and GPU fluxes agree: True</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul><li>“CuPy provides GPU accelerated version of many NumPy and Scipy
functions.”</li>
<li>“Always have CPU and GPU versions of your code so that you can
compare performance, as well as validate your code.”</li>
</ul></div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</div>



      </div> <!-- / div.lesson-content -->
    </main><!-- / main#main-content.main-content --><nav class="bottom-pagination mx-md-4" aria-label="Previous and Next Chapter"><div class="d-block d-sm-block d-md-none">
        <a class="chapter-link" href="../instructor/introduction.html"><i aria-hidden="true" class="small-arrow" data-feather="arrow-left"></i>Previous</a>
        <a class="chapter-link float-end" href="../instructor/numba.html">Next<i aria-hidden="true" class="small-arrow" data-feather="arrow-right"></i></a>
      </div>
      <!-- content for large screens -->
      <div class="d-none d-sm-none d-md-block">
        <a class="chapter-link" href="../instructor/introduction.html" rel="prev">
          <i aria-hidden="true" class="small-arrow" data-feather="arrow-left"></i>
          Previous: Introduction
        </a>
        <a class="chapter-link float-end" href="../instructor/numba.html" rel="next">
          Next: Accelerate your...
          <i aria-hidden="true" class="small-arrow" data-feather="arrow-right"></i>
        </a>
      </div>
    </nav></div> <!-- / div.primary-content.col-xs-12 -->
<!-- END:   inst/pkgdown/templates/content-instructor.html-->

      </div><!--/div.row-->
      		<footer class="row footer mx-md-3"><hr><div class="col-md-6">
        <p>This lesson is subject to the <a href="CODE_OF_CONDUCT.html">Code of Conduct</a></p>
        <p>

        <a href="https://github.com/carpentries-incubator/lesson-gpu-programming/edit/main/episodes/cupy.Rmd" class="external-link">Edit on GitHub</a>

	
        | <a href="https://github.com/carpentries-incubator/lesson-gpu-programming/blob/main/CONTRIBUTING.md" class="external-link">Contributing</a>
        | <a href="https://github.com/carpentries-incubator/lesson-gpu-programming/" class="external-link">Source</a></p>
				<p><a href="https://github.com/carpentries-incubator/lesson-gpu-programming/blob/main/CITATION" class="external-link">Cite</a> | <a href="mailto:instructors@esciencecenter.nl">Contact</a> | <a href="https://carpentries.org/about/" class="external-link">About</a></p>
			</div>
			<div class="col-md-6">

        <p>Materials licensed under <a href="LICENSE.html">CC-BY 4.0</a> by the authors</p>

        <p>Template licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/" class="external-link">CC-BY 4.0</a> by <a href="https://carpentries.org/" class="external-link">The Carpentries</a></p>
        <p>Built with <a href="https://github.com/carpentries/sandpaper/tree/0.16.10" class="external-link">sandpaper (0.16.10)</a>, <a href="https://github.com/carpentries/pegboard/tree/0.7.7" class="external-link">pegboard (0.7.7)</a>, and <a href="https://github.com/carpentries/varnish/tree/1.0.5" class="external-link">varnish (1.0.5)</a></p>
			</div>
		</footer></div> <!-- / div.container -->
	<div id="to-top">
		<a href="#top">
      <i class="search-icon" data-feather="arrow-up" role="img" aria-label="Back To Top"></i><br><!-- <span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top --><span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top
		</a>
	</div>
  <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "TrainingMaterial",
  "@id": "https://carpentries-incubator.github.io/lesson-gpu-programming/instructor/cupy.html",
  "inLanguage": "en",
  "dct:conformsTo": "https://bioschemas.org/profiles/TrainingMaterial/1.0-RELEASE",
  "description": "A Carpentries Lesson teaching foundational data and coding skills to researchers worldwide",
  "keywords": "high-performance computing, HPC, graphics processing units, GPU",
  "name": "Using your GPU with CuPy",
  "creativeWorkStatus": "active",
  "url": "https://carpentries-incubator.github.io/lesson-gpu-programming/instructor/cupy.html",
  "identifier": "https://carpentries-incubator.github.io/lesson-gpu-programming/instructor/cupy.html",
  "dateCreated": "2020-09-25",
  "dateModified": "2024-11-04",
  "datePublished": "2024-11-12"
}

  </script><script>
		feather.replace();
	</script></body></html><!-- END:   inst/pkgdown/templates/layout.html-->

